<head>
  <title>Mat Dombrock</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8"/>
</head>
<div class="header">
  <h1><a href="/"><img src="/favicon.ico" width="25px" >Mathieu Dombrock</a></h1>
  
</div>
<small id="tagline" class="tagline" onclick="loadTagline()" style="cursor:pointer;">"Baseless claims & crimes against computing."</small>
<hr>
<div class="nav">
  <a href="/">home</a> |
  <a href="/about.html">about</a> |
  <a href="/search.html">search</a> |
  <a href="https://github.com/matdombrock" target="_blank">github</a> |
  <a href="https://replicataudio.com" target="_blank">replicataudio</a> |
  <input type="text" placeholder="local search" id="nav-search" style="float:right;">
</div>
<hr>

<script>
  document.getElementById('nav-search').addEventListener("keydown", function (e) {
      if (e.code === "Enter") {  //checks whether the pressed key is "Enter"
          search()
      }
  });

  function search(){
    window.location.href = "/search.html?s="+encodeURIComponent(document.getElementById('nav-search').value);
  }
  const quotes = [
    "Baseless claims & crimes against computing.",
    "Something should go here...",
    "This is a website.",
    "Did you see how fast this page loaded?",
    "Down with the OOP!",
    "I for one, welcome our new robot overlords.",
    "Is this thing on?",
    "Does anyone read this?",
    "Drink more water.",
    "This site, but it's John Coltrane's 'Giant Steps'.",
    "You are the "+Math.random()*10e6+"th visitor!",
    "SMASH that like button!",
    "Web 4.0",
    "Now available in color!",
    "Now available on 5G!",
    "Now available in VR!",
    "Did you notice these change every time?",
    "This site contains a secret game().",
    "Version Number: "+Math.random()*10+"."+Math.random()*10,
    "Click me!",
    "What is this? 1997?",
    "Thanks for visiting.",
    "Yet another tech blog.",
    "Yet another Warcraft 3 Map.",
    //
    "EX-TER-MIN-ATE! EX-TER-MIN-ATE!",
    "We also have a rogue robot policy.",
    "Give me an analysis, Joey.",
    "You didn't tell me you could fly!",
    "What's that ROBOT doing here?",
    
  ];
  function loadTagline(){
    document.getElementById('tagline').innerHTML = '"'+quotes[Math.floor(Math.random() * quotes.length)]+'"';
  }
  loadTagline();
  function game(input){
    console.log("This is a game (true me)");
    console.log("You said: "+input);
    if(input === 1337){
      console.log('win');
    }else{
      alert('fail');
      window.location.replace("https://youtu.be/dQw4w9WgXcQ");
    }
  }

</script><style>/*

Monokai Sublime style. Derived from Monokai by noformnocontent http://nn.mit-license.org/

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #23241f;
}

.hljs,
.hljs-tag,
.hljs-subst {
  color: #f8f8f2;
}

.hljs-strong,
.hljs-emphasis {
  color: #a8a8a2;
}

.hljs-bullet,
.hljs-quote,
.hljs-number,
.hljs-regexp,
.hljs-literal,
.hljs-link {
  color: #ae81ff;
}

.hljs-code,
.hljs-title,
.hljs-section,
.hljs-selector-class {
  color: #a6e22e;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-name,
.hljs-attr {
  color: #f92672;
}

.hljs-symbol,
.hljs-attribute {
  color: #66d9ef;
}

.hljs-params,
.hljs-class .hljs-title {
  color: #f8f8f2;
}

.hljs-string,
.hljs-type,
.hljs-built_in,
.hljs-builtin-name,
.hljs-selector-id,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-addition,
.hljs-variable,
.hljs-template-variable {
  color: #e6db74;
}

.hljs-comment,
.hljs-deletion,
.hljs-meta {
  color: #75715e;
}
</style><style>/*rgb(228, 172, 106);*/
:root{
  --bg:rgb(42, 42, 42);
  --main:rgb(254, 100, 216);
  --secondary:rgb(147, 220, 240);/*rgb(255, 131, 104);*/
  --highlight:rgb(252, 179, 211);
  --text:rgb(224, 220, 214);
}
body{
  font-family: Arial, sans-serif;
  background:var(--bg);
  color:var(--text);
  margin:0 auto;
}
body::selection { color: var(--highlight) }
a{
  color:var(--highlight);
  transition:all 0.2s;
  font-family: 'Courier New', monospace;
}
a:hover{
  color:var(--highlight);
}
blockquote{
  border-left:3px solid var(--secondary);
  padding-left:1rem;
  color:var(--secondary);
}
img{
  max-width:100%;
}
small{
  color:var(--secondary);
}
h1{
  color:var(--text);
}
h1 a{
  text-decoration: none;
  color:var(--text);
}
h1,h2,h3,h4{
  color:var(--secondary);
  font-family: 'Courier New', monospace;
}
/* hr{
  border-color: var(--text);
  outline-color: var(--text);
} */
.header{
  background-image: url('/img/md-banner.jpg');
  background-size: cover;
  background-position: center;
  min-height:300px;
  padding:1rem;
}
.tagline{
  padding:1rem;
  display: block;
  text-align: right;
}
.archive-msg{
  background:red;
  color:var(--text);
  padding:1rem;
}
.nav{
  padding:1rem;
}
.nav a{
  text-decoration: none;
}
.ss-content{
  max-width:1000px;
  margin-left:10vw;
  padding:1rem;
}
@media only screen and (max-width: 1200px) {
  .ss-content{
    margin-left:0;
  }
}
.footer{
  padding:1rem;
}
/* GH Repo card override*/
.repo-card a{
  color:var(--highlight)!important;
}
</style><div class="ss-content"><script>const ssmeta=
{
  "title":"Exploring the Game of Life",
  "description":"Exploring the Game of Life",
  "tags":""
}
;</script>
<p>Everything I am about to write is false, but everything I will tell you with these words is true. To understand mathematics is to understand life, to understand life is to understand the inherent contradictions in our understanding of mathematics.</p>
<p>At the core of reality there is a problem. And the harder we look at that problem the bigger it becomes. Until it becomes so large that it is seen in everything, and at this point is ceases to be a problem. </p>
<p>This problem is sometimes called a paradox or a contradiction. We would like to think that such things should not and can not exist at the core of reality. Yet anyone who looks hard enough will find that they do. We seem to be oscillating between existence an non-existence and so does the situation we occupy called reality.</p>
<p>To know and to prove are not the same thing, but perhaps to exist and to not exist are. Can be be true that we exist be also unprovable? According to GÃ¶del theorem it is this is not only possible but entirely plausible. </p>
<p>Let us stop considering ourselves for a moment (I know that can be hard) and instead question what it means to exist at all. What does it mean for anything to exist? </p>
<p>If not existing is 0 then to exist must be 1. Something either exists or it does not. This must be true right? Maybe not.</p>
<p>A superposition refers to the ability of a quantum system, such as an atom or a subatomic particle, to exist in multiple states or configurations simultaneously. In classical physics, a system can only exist in one state at a time, but in quantum physics, a system can exist in multiple states simultaneously.</p>
<p>An example of superposition is the famous "Schrodinger's cat" thought experiment, which illustrates how a cat in a sealed box could be both alive and dead at the same time, until someone opens the box to observe the cat's state.</p>
<p>It's important to note that superposition is a fundamental principle of quantum mechanics, and it is not limited to subatomic particles, but it also applies to other quantum systems such as quantum bits, or qubits, which are used in quantum computing. In quantum computing, a qubit can exist in multiple states simultaneously, allowing it to perform multiple calculations at the same time, which could make quantum computers much faster and powerful than classical computers.</p>
<p>The world of cellular automata is much more concrete than that of quantum physics. And I promise from this point on, I will stick to discussing pure math and physical computing to avoid the risk of sounding too much like an uneducated new age philosopher. Don't worry, my aim is not convince you that you have a soul or anything like that. Soon enough we will get to some good old fashioned algebra. </p>
<p>For now, Let's discuss something that at this point, I think we can all agree has never and will never exist. </p>
<h2 id="golems">Golems</h2>
<p>In Jewish folklore, an golem&nbsp;is an animated, anthropomorphic being, which is entirely created from inanimate matter, usually clay or mud. The creation of a golem is often attributed to a rabbi or other religious leader, who would use Jewish mysticism and magic to bring the creature to life. According to traditional accounts, the golem was typically made from clay or mud, and then brought to life through the use of the Hebrew word "emet" (truth) written on its forehead.</p>
<p>Once activated, the golem would typically be programmed to carry out specific tasks or obey simple commands. They were often used to protect Jewish communities from persecution or violence, and were said to have superhuman strength and the ability to understand and obey simple commands.</p>
<p>The golem would be deactivated by erasing the first letter of the word emet (aleph) on its forehead, turning the word to "met" (dead), which would cause the golem to lose its animation and become a lifeless clay statue again. It was also said that if the golem was not deactivated and it continued to exist, it would become more aggressive, irrational and uncontrollable, turning against its creator and the community.</p>
<h1 id="automata">Automata</h1>
<p>The ancient Greek concept of automata refers to self-operating machines or devices. These devices were often used in Greek mythology, literature and art as a representation of technology and artificial intelligence. The ancient Greek engineer, mathematician and inventor Hero of Alexandria (Heron) is considered as the first person who wrote about automata. He wrote a book "Pneumatica" and described many designs for automata.</p>
<p>Classical Automata were typically powered by steam, water, or other natural forces (not unlike the electrical automata of today), and were designed to perform a wide range of tasks, from simple mechanical movements to more complex functions such as singing or playing musical instruments. They were often used in religious ceremonies and festivals, as well as in theater performances, to entertain and amaze audiences.</p>
<p>Some of the most famous examples of ancient Greek automata include the bronze statues of Talos, a mythical giant automaton made by the god Hephaestus, who protected the island of Crete, and the "Perpetual Motion Water Clock" a device that used water to power a clock-like mechanism and was said to have been created by the philosopher Plato.</p>
<p>The ancient Greek concept of automata is similar to modern concepts of computer programs, robots, and AI in several ways:</p>
<ul>
<li><p>Both automata and computer programs are designed to perform specific tasks or functions. Automata were created to carry out simple mechanical movements or more complex functions such as singing or playing musical instruments, while computer programs are designed to perform a wide range of tasks, from simple calculations to more advanced functions such as image recognition and natural language processing.</p></li>
<li><p>Both automata and robots are physical machines that can be programmed to perform specific tasks. Automata were typically powered by steam, water, or other natural forces, and were designed to perform a wide range of tasks, while robots are electronic devices that can be programmed to carry out a variety of functions, from manufacturing to search and rescue operations.</p></li>
<li><p>Both ancient Greek automata and AI are based on the idea of creating machines that can perform tasks that would normally require human intelligence. Ancient Greek automata were created to perform specific tasks such as singing or playing musical instruments, while AI is focused on creating machines that can learn and adapt to perform tasks that would normally require human intelligence.</p></li>
<li><p>Both ancient Greek automata and modern AI systems use sensors and feedback mechanisms to react to their environment. Ancient Greek automata used basic mechanical sensors such as levers and gears to react to changes in their environment, while modern AI systems use advanced sensors and algorithms to perceive and respond to their environment.</p></li>
</ul>
<p>In almost any way imaginable we can consider computer programs, robots, and AI to be the successors of, if not one and the same with Classical Automata.</p>
<h2 id="cellularautomata">Cellular Automata?</h2>
<p>Generally speaking, an automaton (plural: automata) is a self-operating machine that can perform a specific set of actions or tasks based on a set of predefined rules. The term "automaton" comes from the Greek word "Î±á½ÏÏÎ¼Î±ÏÎ¿Î½" (automaton), which means "self-acting" or "self-moving." </p>
<p>Automata can be classified into several types depending on their function and the way they operate. Some examples include:</p>
<ul>
<li><p>Mechanical automata, which are physical machines that use mechanical components like gears, levers, and cams to perform their tasks.</p></li>
<li><p>Electro-mechanical automata, which use a combination of mechanical and electrical components to operate.</p></li>
<li><p>Electronic automata, which use electronic components like transistors and microcontrollers to perform their tasks.</p></li>
<li><p>Software automata, which are computer programs that can perform a set of predefined tasks based on a set of rules.</p></li>
</ul>
<p>Automata can also be classified based on the way they are controlled, examples are:</p>
<ul>
<li><p>Finite state automata, which have a finite number of states and transition between them based on a set of predefined rules.</p></li>
<li><p>Cellular automata, which are mathematical models used to simulate the behavior of a collection of cells or particles that interact with each other based on a set of rules.</p></li>
<li><p>Turing machine, which is an abstract theoretical model of a general-purpose computer that can perform any calculation that is algorithmically computable.</p></li>
</ul>
<p>An Automata is a self-operating machine that can perform a specific set of actions or tasks based on a set of predefined rules, they can be mechanical, electronic, software based and controlled by different type of automata.</p>
<p>Cellular automata (CA) is a mathematical model used to simulate the behavior of a collection of cells or particles that interact with each other based on a set of rules. The cells or particles are arranged in a grid, and the rules dictate how the state of a cell or particle changes over time based on the state of its neighboring cells or particles. Cellular automata can be used to model a wide range of systems, from physical phenomena like fluid flow and crystal growth to more abstract systems like traffic patterns and the spread of disease. One of the most famous example of Cellular Automata is Conway's Game of Life, a "zero-player game" that is a simulation of the life and death of cells in a grid (or a matrix).</p>
<h2 id="conwaysgameoflife">Conway's "Game of Life"?</h2>
<p>Conway's Game of Life is a cellular automaton simulation created by mathematician John Horton Conway in 1970. It is a "zero-player game", meaning that its evolution is determined by its initial state, requiring no further input from the user. The "game" consists of a grid of cells, each of which can be in one of two states: "alive" or "dead." The state of each cell in the next generation is determined by the state of its eight neighboring cells, according to a set of rules. </p>
<h3 id="therules">The Rules</h3>
<p>There rules of Conway's Game of Life are very simple. And the best part is there are only 4 rules. So they are easy to remember:</p>
<ol>
<li>Any live cell with fewer than two live neighbors dies, as if by underpopulation.</li>
<li>Any live cell with two or three live neighbors lives on to the next generation.</li>
<li>Any live cell with more than three live neighbors dies, as if by overpopulation.</li>
<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>
</ol>
<p>We can even condense these into 3 rules if we wanted:</p>
<ol>
<li>Any live cell with two or three live neighbors survives.</li>
<li>Any dead cell with three live neighbors becomes a live cell.</li>
<li>All other live cells die in the next generation. Similarly, all other dead cells stay dead.</li>
</ol>
<p>Although the rules themselves are very simple, the behavior that emerges from these rules can be highly complex. For example, patterns called "gliders" and "spaceships" can move across the grid, while other patterns can oscillate or grow indefinitely. The game can also give rise to patterns that appear to be chaotic, with no clear pattern or structure.</p>
<p>The Game of Life has even been found to be a Turing complete system, meaning that it is capable of simulating any other system that can be described with an algorithm. The Game of Life can simulate a universal constructor, a Von Neumann universal constructor, universal Turing machine, and even a universal computer. It is a simple cellular automaton simulation with a very simple rule set, but it can lead to very complex behavior and it is even capable of simulating any other system that can be described with an algorithm (<a href="https://www.youtube.com/watch?v=xP5-iIeKXE8">including the Game of Life</a>).</p>
<p>We can also think of the first part of these rules as being conditions:</p>
<ol>
<li>Neighbors &lt; 2</li>
<li>Neighbors = 2</li>
<li>Neighbors = 4</li>
<li>Neighbors &gt; 3</li>
</ol>
<p>To make a complete rule we need to assign an "action" to the condition. In the Game of Life, there are 3 possible actions that can be taken when any given condition is met. These can be called many different things, but I will define them as follows:</p>
<ol>
<li>Survive: A living cell continues to live.</li>
<li>Thrive: A living cell continues to live. If the position is unoccupied (no living cell lives here) then a new cell is born at this position.</li>
<li>Die: A living cell will die.</li>
</ol>
<p>To put our conditions and actions together into the rule set for the Game of Life would look something like this:</p>
<ol>
<li>Neighbors < 2 -> Die</li>
<li>Neighbors = 2 -&gt; Survive</li>
<li>Neighbors = 3 -&gt; Thrive</li>
<li>Neighbors &gt; 3 -&gt; Die</li>
</ol>
<h1 id="docellsmove">Do Cells Move?</h1>
<p>When looking at the output from the game of life, it can seem like the cells are moving. However, the simple answer to this question is that according to the formal system that is the "Game of Life", the cells do not and can not move. Cells can only be be born, die, or continue living exactly where they were born. </p>
<p>The illusion of movement in something like a "glider" is only that, an illusion. What we are actually seeing is a kind of "chain reaction" happening amongst the population. </p>
<p>To give a simple example of this, consider the following "organism":</p>
<pre><code class="hljs"><span class="hljs-number">0A0</span>
<span class="hljs-number">0B0</span>
<span class="hljs-number">0C0</span>
</code></pre>
<p>Cell "A" has only 1 neighbor so it will die. </p>
<p>Cell "B" has 2 neighbors, so it will continue to live. </p>
<p>Cell "C" has has only 1 neighbor so it will die. </p>
<p>However, what about the cells at 0,1 (left middle) and 2,2 (right middle)? Let's call these cells "D" and "E". The cells each have 3 neighbors right now. So they will be born on the next generation. Since they are about to be born, we might as well give them names too. </p>
<pre><code class="hljs"><span class="hljs-number">0</span>A0
<span class="hljs-symbol">DBE</span>
<span class="hljs-number">0</span><span class="hljs-built_in">C0</span>
</code></pre>
<p>Note: I'm currently showing 2 generations at once. Remember that each generation is calculated fully before any new cells are born or die.</p>
<p>So we know now that in the next generation, cells "A" and "C" will die and cells "D" and "E" will be born. It might be tempting to think of the next generation as being something like this:</p>
<pre><code class="hljs">000
ABC
000
</code></pre>
<p>This satisfies our human desire to recognize simple patterns and movement. However, we know that's not actually true. We could say that cells "D" and "E" are children of cells "A", "B", and "C", but we can't say with any conviction, that these cells ARE "A" or "B". Once again, since cells can only be born, die or live (exactly where they were born) they simply can not move. </p>
<h2 id="achilleszeno">Achilles &amp; Zeno</h2>
<p>But let me ask you this: </p>
<p>"<em>Does anything actually move?</em>"</p>
<p>The Achilles Paradox of movement is a thought experiment used to illustrate the concept of Zeno's paradoxes. The Achilles Paradox is named after the famous Greek warrior Achilles who is said to have been able to run faster than any other mortal. The paradox states that in order for Achilles to catch up to a slower runner, he must first reach the point where the slower runner started. But before he can reach that point, he must reach the point halfway between where he is and where the slower runner started. And before he can reach that point, he must reach the point halfway between that point and where the slower runner started, and so on. In this way, Achilles must complete an infinite number of intermediate steps before he can reach the slower runner, making it impossible for him to catch up.</p>
<p>This paradox is used to illustrate how the concept of infinite divisibility can lead to logical contradictions and difficulties in the understanding of motion and time. The paradox is also related to the concept of continuity and the idea that motion is not a sequence of discrete steps, but a continuous process.</p>
<p>The concept of Zeno's paradoxes are related to the idea of infinite divisibility, where one could divide a distance or time infinitely, making it impossible for something to move or reach a point. This paradox is used to illustrate the concept of motion and time, but also it was also used in the field of mathematics and physics to question the concept of continuity and the nature of space-time.</p>
<p>Achilles must reach the point halfway between where he is and where the slower runner started and so on, making it impossible for him to catch up. It is used to illustrate the concept of infinite divisibility and the difficulties in the understanding of motion and time.</p>
<p>Zeno's paradoxes can be related to the movement of cells in Conway's Game of Life in the sense that the cells in the game can be seen as moving through a series of discrete steps, rather than a continuous process. Since the game is played on a grid, with each cell in one of two states: "alive" or "dead.", the state of each cell in the next generation is determined by the state of its eight neighboring cells, according to a set of predefined rules. In this way, the cells can be seen as moving through a series of discrete steps, with each step determined by the state of its neighboring cells.</p>
<p>This idea of infinite divisibility and the need to complete an infinite number of intermediate steps can also be applied to the movement of cells in the Game of Life. In order for a cell to reach a new state, it must first reach the halfway point between its current state and the new state. And before it can reach that point, it must reach the halfway point between that point and the new state, and so on. In this way, the cell must complete an infinite number of intermediate steps before it can reach the new state, making it impossible for it to change its state.</p>
<p>Similar to how Zeno's paradox states that in order to reach a point, an infinite number of intermediate steps must be completed, making it impossible. This idea of infinite divisibility and the need to complete an infinite number of intermediate steps can be applied to the movement of cells, making it impossible for a cell to reach a new state.</p>
<h2 id="sodoesanythingactuallymove">So Does Anything Actually Move?</h2>
<p>Obviously, according to everything our senses tell us, things are moving. If we look at a waving flag or waves in the ocean (or the Game of Life), their state is clearly changing from one second to the next. But what does it mean to change?</p>
<p>Maybe we could say that what is actually moving (at least according to our perception) is time. Maybe things can change and move, but only "across time". Furthermore, maybe it's possible that there is a core difference between pure math and physical reality. </p>
<p>The solution to Zeno's paradoxes is based on the concept of the limit, and the idea that the infinite sequence of intermediate steps can be thought of as a mathematical construct, rather than a physical reality.</p>
<p>One way to think about the solution to Zeno's paradox is to consider the infinite sequence of intermediate steps as a geometric series. A geometric series is a sequence of numbers where each term is a fixed multiple of the previous term. In the case of Zeno's paradox, each term in the sequence represents the distance that Achilles must cover to reach the next point in his journey. The sum of an infinite geometric series can be calculated using the formula:</p>
<pre><code class="hljs"><span class="hljs-attr">S</span> = a / (<span class="hljs-number">1</span> - r)
</code></pre>
<p>Where "a" is the first term in the series, and "r" is the common ratio. In the case of Zeno's paradox, "a" represents the initial distance between Achilles and the slower runner, and "r" represents the ratio of the distance that Achilles must cover at each step.</p>
<p>Using this formula, it can be shown that the infinite sequence of intermediate steps can be thought of as a mathematical construct, rather than a physical reality. The sum of an infinite geometric series is finite and Achilles can reach the end point in a finite amount of time.</p>
<p>Another solution to Zeno's paradox is to consider the concept of continuity, and the idea that motion is not a sequence of discrete steps, but a continuous process. The infinite sequence of intermediate steps can be thought of as an abstraction, rather than a physical reality. The concept of continuity was formalized by the mathematician Weierstrass, and it states that for any finite distance, there is a set of points that is arbitrarily close to the end-point, and there will always be another point closer to the end-point.</p>
<p>The solution to Zeno's paradox is based on the the idea that the infinite sequence of intermediate steps can be thought of as a mathematical construct, rather than an absolute truth. One way to think about the solution is to consider the infinite sequence of intermediate steps as a geometric series with a finite sum, and the other way is to consider the concept of continuity and the idea that motion is not a sequence of discrete steps, but a continuous process.</p>
<p>So maybe, the cells in the Game of Life <em>are</em> moving after all. Maybe, the solution to Zeno's paradox can also be applied to the movement of cells?</p>
<p>One way that this solution could be used to suggest that the cells in the game of life are in fact moving is by considering the concept of the limit. Just as the infinite sequence of intermediate steps in Zeno's paradox can be thought of as a mathematical construct rather than a physical reality, the sequence of steps that a cell takes to reach a new state in the Game of Life can also be thought of as a mathematical construct.</p>
<p>In the Game of Life, the state of each cell in the next generation is determined by the state of its eight neighboring cells, according to a set of predefined rules. Each step in this sequence can be thought of as a fixed multiple of the previous step, similar to the geometric series in the solution to Zeno's paradox. The sum of this infinite sequence of steps can be thought of as a mathematical construct, with the final state of the cell being a limit of this sequence.</p>
<p>Another way that the solution to Zeno's paradox could be used to suggest that the cells in the game of life are in fact moving is by considering the concept of continuity. Just as motion is not a sequence of discrete steps, but a continuous process, the movement of cells in the Game of Life can also be thought of as a continuous process. The sequence of steps that a cell takes to reach a new state can be thought of as an abstraction, rather than a physical reality. The concept of continuity formalized by Weierstrass states that for any finite steps, there is a set of states that is arbitrarily close to the end-state, and there will always be another state closer to the end-state.</p>
<p>By considering the concept of the limit, where the final state of the cell is a limit of this sequence and by considering the concept of continuity where the movement of cells can be thought of as a continuous process, the cells in the game of life are in fact moving.</p>
<h1 id="possibleoutcomes">Possible Outcomes</h1>
<p>There are 4 basic "outcomes" that can happen in the Game of Life.</p>
<ol>
<li>All cells die off and the game is over</li>
<li>The populations "freezes" (stabilizes) and no further activity (births or deaths) can occur</li>
<li>The population oscillates (loops) forever in an endless cycle</li>
<li>Cells continue to be born forever and the game never ends</li>
</ol>
<p>These outcomes are not to be confused with "classes" of organisms which will be covered in a later section. To clarify for now, here are some examples of states which I do not consider to be an "outcome":</p>
<ul>
<li><p>Gliders and spaceships: These are patterns that move across the grid, leaving behind a trail of dead cells. Gliders and spaceships are examples of patterns that exhibit emergent behavior, as the movement of these patterns is not explicitly defined in the rules of the game. These are not considered distinct from outcome #2 mentioned above. </p></li>
<li><p>Growing patterns: These are patterns that continue to grow and expand over time. Some examples of growing patterns include the "glider gun" and "breeder" patterns. These are not considered distinct from outcome #2 mentioned above.</p></li>
<li><p>Chaotic patterns: These are patterns that do not exhibit any clear structure or pattern. The cells in these patterns may appear to be random and unpredictable. These are not an outcome in and of themselves, they could resolve to any of the possible outcomes listed above. </p></li>
<li><p>Universal constructors: These are patterns that are able to construct other patterns, including copies of itself. They are able to simulate a universal constructor, a Von Neumann universal constructor, universal Turing machine, and even a universal computer. These are not an outcome in and of themselves, they could resolve to any of the possible outcomes listed above. </p></li>
</ul>
<h2 id="outcomesvsresolutions">Outcomes vs Resolutions</h2>
<p>We can define an outcome as we did above. We can define "activity" as being any amount of birth or death withing a population. An "outcome" however, does not mean a final resolution. It does not mean that no more activity may occur in later generation. For example, consider outcome #4, this clearly is not a final resolution. An "outcome" is simply where the simulation ends for one reason or another. A "resolution" should be "provable" outcome that is not dependant on the generation count of the simulation. </p>
<p>We run into a very interesting problem if we want to talk about final resolutions in the game of life. Most outcomes are in fact resolutions. For example outcome #1 is that all the cells die. After that, we know that no new activity can occur. This is a proper resolution. </p>
<p>We can say the same about outcome #2. If the we see one single generation without any new births or deaths, we can be sure that the next generation can not have any activity because the next generation is exactly the same as the last (which had no activity). This is due to the deterministic nature of the rule set. </p>
<p>We can even say the same thing about outcome #3. If we can prove that we have a stable oscillation, then we can be sure that no new activity is possible outside the states of that oscillation. Continuing to run the simulation after we have identified that all cells are either dead, frozen or in a stable oscillation would yield no new information after one cycle of the oscillation. The question of how we can "prove" an oscillation is stable is the topic of another section. </p>
<p>This brings us to the last outcome (#4) which is "Cells continue to be born forever and the game never ends". This seems like a fairly simple statement to make on the surface however when we look more closely, it breaks down fast. Say that we simulated a population for 100 generation and it is still continuing to grow. If we stop there, how can we say it will not die on the next generation? The <strong>only</strong> way we can say that for sure is to apply the rules of the game to the current generation (thus simulating one more generation). Say we do that and the generation does not die, how can we know that it wont die in the next 100 generations? The only way to be sure is to simulate 100 more generations. This can be said about any population that has not reached a resolution. There is no way to be sure about its ultimate fate unless we simulate it all the way to its resolution.</p>
<h2 id="thehaltingproblem">The Halting Problem</h2>
<p>The Halting Problem is a famous problem in the field of theoretical computer science, first posed by Alan Turing in 1936. It asks whether it is possible to determine, given a description of a computer program and an input, whether the program will ever stop running or continue running indefinitely. The problem is considered to be unsolvable, as it was proven by Alan Turing in his 1936 paper that there is no general algorithm that can determine if an arbitrary program halts for all inputs. This result is a cornerstone of theoretical computer science and is used to prove the limits of what computers can do.</p>
<p>In the context of the Halting Problem, a "computer" referred to as "H" is a theoretical machine that is able to determine, for any given computer program and input, whether the program will ever stop running or continue running indefinitely. The existence of such a machine would allow for the solution of the Halting Problem and it is important to note that this is not possible according to the proof. The proof shows that no such general algorithm, or computer H, can exist, and that the Halting Problem is undecidable.</p>
<p>The reason that a theoretical machine, or "computer" H, cannot solve the Halting Problem is because of a self-referential paradox known as "diagonalization" or "Turing's Paradox" which is involved in the problem. The idea is that if such a machine H existed, one could use it to create a new program that could ask H whether the new program halts or not, and then do the opposite of what H says. For example, if H says that the new program halts, the program could be made to not halt, and vice versa. This creates a paradox, as H cannot determine if this new program halts or not, and therefore it cannot determine if any other program halts or not, thus showing that such a general algorithm or computer H cannot exist.</p>
<p>In the context of the Halting Problem, diagonalization is a technique used to show that a theoretical machine, or "computer" H, cannot exist. The idea behind diagonalization is to use a program, which takes as input a description of a program and an input, and produces a new program that behaves differently from the given program on that input.</p>
<p>The new program is constructed in such a way that it simulates the given program on all inputs, but does the opposite of what the given program does on one specific input. This creates a self-referential paradox, as the new program can be used as an input for H, and H will not be able to determine if the new program halts or not.</p>
<p>For example, if H says that the new program halts, the new program could be made to not halt, and vice versa. This shows that H cannot determine if any program halts or not, and thus it cannot exist. This technique is called diagonalization after the diagonal elements of the table of computations of all programs on all inputs, which is the object that is constructed and used to create the new program.</p>
<p>Diagonalization can also be explained in terms of natural numbers, which are the positive integers, and real numbers, which are the set of numbers that include the natural numbers, fractions, and irrational numbers.</p>
<p>Imagine a table of all possible computations of all programs on all inputs, where the rows correspond to the programs and the columns correspond to the inputs. Each cell in the table contains the outcome of the program on the corresponding input, represented by a natural number.</p>
<p>With diagonalization, we can create a new number, which is not in the table, by taking the nth digit of the nth number in the table (where n is the row and column number of the cell).</p>
<p>This new number is different from all the numbers in the table, and it can be used as an input for a program. Now, if we use the new number as an input for the program in the nth row of the table, the outcome will be different from the number in the nth cell.</p>
<p>This creates a self-referential paradox, as the new number can be used as an input for any program, and that program will not halt on that input if and only if the program in the nth row of the table halts on the nth input. This shows that it is not possible to determine a general algorithm that can determine if an arbitrary program halts for all inputs and that's why it is undecidable.</p>
<p>Consider the following example:</p>
<pre><code class="hljs">   <span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>
<span class="hljs-attribute">1</span> |<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>|
<span class="hljs-attribute">2</span> |<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>|
<span class="hljs-attribute">3</span> |<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>|
<span class="hljs-attribute">4</span> |<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>|
</code></pre>
<p>This example illustrates that it is not possible to determine a general algorithm that can determine if an arbitrary program halts for all inputs and that's why it is undecidable.</p>
<p>In this example, the rows correspond to different programs and the columns correspond to different inputs. Each cell in the table contains the outcome of the program on the corresponding input, represented by a natural number. For example, the number in the cell (1,2) is 1 which means that the first program halts on the second input.</p>
<p>With diagonalization, we can create a new number by taking the nth digit of the nth number in the table (where n is the row and column number of the cell). For example, we take the number in the cell (2,2) which is 1, then we take the number in the cell (2,3) which is 1 and so on. The new number we get is 1110.</p>
<p>Now, let's say we have another program that takes this new number as input. We can see that the outcome of this program on this input is 0, which is different from the number in the cell (2,2) which is 1. This creates a self-referential paradox, as we can use the new number as an input for any program and that program will not halt on that input if and only if the program in the nth row of the table halts on the nth input.</p>
<h2 id="definingpossibleresolutions">Defining Possible Resolutions</h2>
<p>To recap, earlier we defined 4 basic "outcomes" that can happen in the Game of Life.</p>
<ol>
<li>All cells die off and the game is over</li>
<li>The populations "freezes" (stabilizes) and no further activity (births or deaths) can occur</li>
<li>The population oscillates (loops) forever in an endless cycle</li>
<li>Cells continue to be born forever and the game never ends</li>
</ol>
<p>Considering that we can not solve the Halting Problem, we could define the possible "resolutions" as follows:</p>
<ol>
<li>All cells die off and the game is over</li>
<li>The populations "freezes" (stabilizes) and no further activity (births or deaths) can occur</li>
<li>The population oscillates (loops) forever in an endless cycle</li>
</ol>
<p>Notice that this is a subset of our list of "outcomes". Outcome #4 can <strong>never</strong> be a resolution, because it would be impossible to run the simulation for an <em>infinite</em> number of generations. Because of that simple fact. We can never prove that a population will have outcome #4. Now this is not to say that there are no populations that <em>could meet outcome #4</em> by continuing to grow forever. This is only to say that we can not prove that. This is not because we are limited by human brain power or by modern computing power. This is analogus to the Achilles paradox of movement in that we can never reach the final state even given an infinite amount of time and computing power. </p>
<p>So, we can say that the first the outcomes are theoretically "provable" since they result in a final resolution where no further activity can occur. However, we can also say that outcome #4 in which the population continues to grow forever is an "un-provable" due to the Halting Problem. </p>
<h1 id="provingoscillationstability">Proving Oscillation Stability</h1>
<p>Earlier I mentioned that it should be possible to prove that a populating is in a stable oscillation. But how is that? Its not as simple to prove stable oscillation as it is to prove that a populations is frozen or dead. </p>
<p>To recap, we can prove that a population is dead simply by counting the number of living cells. If the count is zero, then the population is dead. We know there can be no further activity. We know this because if all cells are dead, then no more cells can die, and because cells require 3 neighbors to be born and each cell now has exactly zero neighbors, we know that no cells can be born in subsequent generations. We know that a population is frozen if generation n is the same as population n-1. We can also think of a frozen population as being one where the last generation had no new births or deaths. This inherently means that there is no difference between the generation n and n-1 since the only mechanisms of change are birth and death.  </p>
<p>Before we can define what it means to have a "stable oscillation" we need to define an "oscillation". In an abstract sense, "oscillation" refers to a repetitive fluctuation or variation between two or more states or values. It can refer to a wide range of physical, mathematical, and abstract phenomena, such as the oscillation of a pendulum, the oscillation of a sound wave, or the oscillation of a mathematical function. The key word to latch on to here is "repetitive". </p>
<p>In the context of the Halting Problem, "oscillation" refers to the repetitive fluctuation of the machine H between halting and non-halting on a particular input, due to the self-referential paradox created by diagonalization.</p>
<p>In general terms, oscillation can be described as a pattern of back and forth motion or change, in which some quantity (such as position, velocity, or amplitude) regularly or irregularly varies between two or more values over time.</p>
<p>Here are a few examples of real-world, practical uses of oscillators that you may be familiar with:</p>
<ul>
<li><p>The swinging of a pendulum: A pendulum is a classic example of an oscillator. It is a weight suspended from a pivot point, and it swings back and forth in a regular, repeating motion.</p></li>
<li><p>The ticking of a clock: Clocks use a mechanism called an oscillator to keep time. A quartz crystal oscillator, for example, uses the natural vibrations of a quartz crystal to create a regular, repeating electrical signal that is used to keep time.</p></li>
<li><p>The vibration of a guitar string: When a guitar string is plucked, it vibrates back and forth in a repeating motion, producing sound waves.</p></li>
<li><p>Oscillation of an electronic circuit: Oscillators are electronic circuits that generate a periodic, oscillating waveform, such as a sine wave or a square wave. These circuits are used in a wide range of electronic devices, including radios, televisions, and computer processors.</p></li>
<li><p>Oscillation of an AC current: Alternating current (AC) oscillates in a back and forth motion, changing direction many times per second. This is the reason why an AC voltage and current is used for power transmission and distribution and are produced by generators in power plants.</p></li>
<li><p>Oscillation of the heart beat: The heart is an oscillator that generates regular, repeating contractions and expansions, pumping blood throughout the body.</p></li>
</ul>
<h2 id="therealworldentropydamping">The "Real World", Entropy &amp; Damping</h2>
<p>In the real, physical world, there is no such thing as a truly stable oscillator since all systems are in a state of entropy.</p>
<p>Entropy is a measure of disorder or randomness in a system, and it is always increasing over time. The second law of thermodynamics states that entropy always increases in closed systems, which means that systems will tend towards disorder and randomness over time.</p>
<p>A closed system is a system that is isolated from its surroundings, and does not exchange matter or energy with its surroundings. In simple terms, it's a system that is "closed off" from the outside world. A closed system can be a physical object, such as a sealed container or a sealed room, or it can be a mathematical or abstract system, such as a set of equations.</p>
<p>For example, a sealed container filled with gas is a closed system, because the gas molecules inside the container cannot escape and new molecules cannot enter. Similarly, a sealed room that is air-conditioned is a closed system, as the air inside the room does not exchange with the air outside.</p>
<p>A closed system can also be an isolated electronic circuit, an isolated part of a machine, or a specific part of a process.</p>
<p>It's important to note that it's not always possible to completely isolate a system from its surroundings, and some interactions may still occur. But the degree of isolation can vary and the system can be considered as closed if the interactions are limited and do not affect the behavior of the system in a significant way.</p>
<p>This means that even in a seemingly stable oscillator, such as a pendulum, there are always small disturbances and fluctuations in the system that cause the oscillations to change over time. For example, the pendulum may be affected by small variations in temperature or air resistance, which can cause the oscillations to change slightly.</p>
<p>In addition, even if an oscillator is perfectly isolated from external disturbances, it will still be affected by internal fluctuations and randomness, caused by the inherent uncertainty and randomness at the quantum level.</p>
<p>Thus, while we may observe an oscillator to be stable over a certain period of time, or within certain parameters, in reality, it will always be affected by entropy and disorder, and its stability is never truly perfect.</p>
<p>It is also worth mentioning that in some cases, the energy of the system is not sufficient to maintain the oscillation, and it will stop over time, this is called "damping". Damping is a mechanism that causes an oscillator (or other system) to lose energy over time, and eventually stop oscillating. Damping can occur in mechanical, electrical, and other types of systems.</p>
<p>There are two main types of damping: viscous damping and frictional damping.</p>
<p>Viscous damping occurs when a fluid, such as air or oil, flows against a moving object, such as a pendulum or a vibrating mechanical system. The fluid creates a force that opposes the motion of the object, causing it to lose energy and slow down.</p>
<p>Frictional damping occurs when two solid surfaces rub against each other, such as the friction between the pivot point of a pendulum and the support or the friction between the moving parts in a machine. Frictional forces also oppose the motion of the object and cause it to lose energy and slow down.</p>
<p>In electronic oscillators, damping can occur due to a resistance in the circuit, which absorbs energy from the oscillations, causing them to decrease in amplitude over time.</p>
<p>In general, damping can also occur due to any other resistance in the system, such as internal resistance in the oscillating element or external resistance from the environment. </p>
<p>Damping is an important factor in the design and operation of many systems, as it can be used to control the amplitude and frequency of oscillations and prevent excessive vibrations or damage to the system.</p>
<p>You might have come to the realization that all of the real world oscillators listed above will not last forever. The all have the common denominator of needing an energy source of some kind to get started or continue moving. Due to the effects of entropy and damping, none of these (or any other real world oscillators) are actually truly stable. </p>
<p>We can think of our cellular automata simulation is being a type of system. If we applied the "outcomes" of our cellular automata simulation we defined above to these oscillators we would see that they all eventually result in outcome #1 (all cells die) or #2 (all cells are frozen). Due to entropy and dampening, we know that real systems (oscillators included) can never result in outcomes #3 (the system loops for ever in an endless cycle) or #4 (the system grows forever).</p>
<h2 id="infinitegrowth">Infinite Growth?</h2>
<p>I think its fairly clear (given the above information) why a real world oscillator can not continue oscillating forever. However, lets consider in more mathematical terms, why a system can not <em>grow forever</em> either. This will be key to understanding wether the oscillators in our system are stable or unstable.  </p>
<p>A population of bacteria might double every second under ideal conditions, such as an unlimited supply of nutrients and optimal temperatures. For example, let's consider a population of bacteria that starts with only one bacterium.</p>
<p>If the population doubles every second, after one second, there would be 2 bacteria, after 2 seconds there would be 4 bacteria, after 3 seconds there would be 8 bacteria, and so on. The number of bacteria would continue to increase exponentially:</p>
<ul>
<li>After 1 second: 1 bacteria x 2 = 2 bacteria</li>
<li>After 2 seconds: 2 bacteria x 2 = 4 bacteria</li>
<li>After 3 seconds: 4 bacteria x 2 = 8 bacteria</li>
<li>After 4 seconds: 8 bacteria x 2 = 16 bacteria</li>
<li>After 5 seconds: 16 bacteria x 2 = 32 bacteria</li>
<li>After 6 seconds: 32 bacteria x 2 = 64 bacteria</li>
<li>After 7 seconds: 64 bacteria x 2 = 128 bacteria</li>
<li>After 8 seconds: 128 bacteria x 2 = 256 bacteria</li>
<li>After 9 seconds: 256 bacteria x 2 = 512 bacteria</li>
<li>After 10 seconds: 512 bacteria x 2 = 1024 bacteria</li>
<li>After 11 seconds: 1024 bacteria x 2 = 2048 bacteria</li>
<li>After 12 seconds: 2048 bacteria x 2 = 4096 bacteria</li>
</ul>
<p>As we can see, the population of bacteria doubles every second, and after 12 seconds the population of bacteria is 4096.</p>
<p>In his seminal work, "Billions &amp; Billions: Thoughts on Life and Death at the Brink of the Millennium," the late, renowned astrophysicist Carl Sagan recounts an ancient fable about the creation of chess. The story goes that, in a distant kingdom, the ruler's chief advisor, the Counselor, gifted him with a new game. The game involved moving pieces around a board with 64 squares, and the most crucial piece was modeled after the King himself, with the Counselor's piece coming in as a close second. The goal of the game was to capture the opposing King. Overjoyed with this new invention, the King asked his Counselor how he would like to be rewarded for his brilliance.</p>
<p>"I am a man of simple needs. My request for compensation is modest, I request a single grain of wheat on the first square, double that on the second, and so on until each square is filled." He told the King. </p>
<p>The King, overcome with joy from this game, offered him jewels, palaces, and dancing girls. But he refused, his only desire was for the small piles of wheat. The King, secretly impressed by his humility, consented to the request.</p>
<p>As the Royal Granary Master began to tally the grain, the King was hit with an unexpected reality. The numbers seemed small at first: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024â¦ but as we reached the 64th square, the numbers became astronomical. In fact, nearing 18.5 quintillion grains. Perhaps my request for compensation was not as modest as the king had originally thought. I can assure you that this kingdom (nor any other kingdom) would not have this volume of grains in their store. To put it in perspective there are less than 18.5 quintillion grains of <strong>sand</strong> in the entire world, it is estimated to be around 7.5 x 10^18 grains. This is a very large number but still significantly less than 18.5 quintillion.</p>
<p>At the rate we observed our bacteria colony growing, we should see the colony take over the entire world in a matter of days. </p>
<p>However, in reality, bacteria do not have unlimited resources and their population will not grow indefinitely. Resource scarcity, such as lack of nutrients, or the presence of toxins, will eventually limit their growth. Additionally, bacteria populations can also be limited by other factors, such as predation or competition with other organisms, in addition to physical factors such as temperature, humidity, and atmospheric pressure.</p>
<p>Therefore, while bacterial populations can grow rapidly under optimal conditions, in reality, their growth is limited by resource scarcity, competition, predation and other environmental factors. They will not and can not grow forever. </p>
<p>In much the same way that a bacteria colony cannot grow indefinitely, any given real-world systems cannot grow forever. The growth of a bacteria colony is limited by resource scarcity, which eventually slows down or stops the growth of the colony. Similarly, any real-world systems, whether they are economic, social, or ecological, have natural limits to their growth as well.</p>
<p>Economic systems, for example, cannot grow indefinitely as they are dependent on finite resources and are limited by the carrying capacity of the planet. As resources become scarce, the cost of extracting them increases, and economic growth slows down. Similarly, social systems such as societies, organizations, or communities have a finite capacity for growth. As the population or membership of these systems increases, the complexity and coordination required also increases, leading to diminishing returns on growth.</p>
<p>Ecological systems are also limited by their carrying capacity, which is determined by the availability of resources and the ability of the ecosystem to absorb waste. As populations of organisms grow, they consume more resources and produce more waste, which can lead to a decline in the health of the ecosystem.</p>
<p>These systems are very "human". They are based heavily in the rules of biology and sociology. But what about mechanical and electro-mechanical systems? </p>
<p>We find the same thing. No real-world mechanical or electro-mechanical system can continue operating or growing ad infinitum for several reasons:</p>
<ol>
<li><p>Energy limitations: All mechanical and electro-mechanical systems require energy to operate. This energy is typically supplied by batteries, generators, or other power sources. However, these power sources have a finite capacity and will eventually run out, causing the system to stop operating.</p></li>
<li><p>Wear and tear: Mechanical and electro-mechanical systems are made up of moving parts that are subject to wear and tear. Over time, these parts will degrade, lose precision, and eventually fail, making it impossible for the system to continue operating.</p></li>
<li><p>Environmental factors: Mechanical and electro-mechanical systems are also subject to environmental factors such as temperature, humidity, and vibration. These factors can cause the system to deteriorate or malfunction, leading to failure.</p></li>
<li><p>Resource Scarcity: Most of the systems rely on a certain amount of resources to keep running, those resources could be materials, energy, or spare parts, those resources are limited and will eventually run out, limiting the system's ability to keep running.</p></li>
<li><p>Complexity: As the system grow larger and more complex, it becomes increasingly difficult to maintain and operate, making it prone to failure.</p></li>
<li><p>Entropy: All physical systems tend towards disorder, which leads to the degradation of the materials, eventually leading to the system's inability to function.</p></li>
</ol>
<p>Therefore, no real-world mechanical or electro-mechanical system can continue operating or growing indefinitely, as all systems are subject to wear and tear, environmental factors, resource scarcity, and the laws of thermodynamics.</p>
<p>But what about systems that can't exist in the real world? For instance, systems that are based on pure mathematics and logic like that of a cellular automata simulation. Theoretically, non-physical systems based on pure math, such as cellular automata simulations, are not subject to the limitation on growth and can exist ad infinitum because they are not constrained by the laws of physics or the availability of resources.</p>
<p>Cellular automata simulations are mathematical models that simulate the behavior of a large number of simple, identical cells that interact with their neighbors according to a set of rules. These simulations are based on mathematical operations and do not require any physical materials or energy. Therefore, they do not experience wear and tear or degrade over time.</p>
<p>Additionally, cellular automata simulations are not subject to environmental factors such as temperature, humidity, or vibration. They can be run on computers, which can control the environment and maintain a stable temperature. In a cellular automata simulation the resources required to keep the system running are minimal, and the resources are not subject to scarcity.</p>
<p>Furthermore, the mathematical models used in these simulations can be made to run indefinitely, without showing signs of wear and tear. They can also be scaled to an arbitrary number of cells without any significant change in the system's behavior.</p>
<h2 id="puremathvsrealitythefightofthecentury">Pure Math vs Reality (The Fight of the Century)</h2>
<p>There is a huge caveat here though. You might have notices that I said "<strong>Theoretically</strong>, non-physical systems based on pure math, such as cellular automata simulations, are not subject to the limitation on growth [â¦]". When we discuss these systems in terms of absolutely pure math then this is entirely correct.</p>
<p>Pure math has no bounds or limits in the sense that mathematical concepts and equations can be extended to an infinite number of values or inputs. For example, a matrix can have an infinite number of cells, and mathematical operations can be performed on each cell without any limitations.</p>
<p>On the other hand, physical computing does involve limits and resource scarcity. Physical computing refers to the use of computers and other physical devices to perform mathematical operations and execute algorithms. These devices are subject to the laws of physics, and as a result, have limitations in terms of processing power, memory, and storage capacity.</p>
<p>For example, consider a matrix with a very large number of cells, say a million. While the mathematical operations on such a matrix can be performed without any limitations, it will be difficult to implement it on a physical computer with limited resources, as it requires a large amount of memory and processing power to store and manipulate such a large matrix. Additionally, even if it is possible, the time required to perform the operations on such a large matrix may be impractical.</p>
<p>Now consider a matrix that extends into infinity on every axis. This is a fairly easy concept to work with in pure math but a technically impossible one to achieve with physical computing. Even if we converted every atom in the universe (known and unknown) and even if the universe was undeniably infinite, we can never actually hold the state of a matrix with infinite axis. This comes back to the concept of diagonalization. Even an infinite amount of discrete storage can not hold hold a continuous set of data.  </p>
<p>Pure math and logic are abstract and idealized representations of reality. They provide a framework for understanding and making predictions about the world, but they do not take into account the complexities and nuances of the physical world. For example, mathematical models of a system can make accurate predictions, but they may not account for all the variables that affect the system in the real world.</p>
<p>To further understand this concept, we can look no further than the ancient teachings of Kabbalah. Kabbalah is a mystical, esoteric tradition that originated in Judaism and has been developed and studied over many centuries. It describes several layers of reality, each of which corresponds to a different level of understanding and consciousness.</p>
<ol>
<li><p>The world of action (Asiyah): This is the physical world we live in, where everything is measurable and observable. It is the realm of the five senses and is considered the lowest level of reality.</p></li>
<li><p>The world of formation (Yetzirah): This is the realm of thoughts, emotions, and imagination. It is the world of ideas, where things take shape and form. It is the realm of the mind and imagination.</p></li>
<li><p>The world of creation (Briyah): This is the realm of pure intellect, where concepts and ideas are created. It is the world of pure intelligence and understanding.</p></li>
<li><p>The world of emanation (Atzilut): This is the realm of pure spirit, where the divine light of God emanates. It is the realm of pure consciousness and is considered the highest level of reality.</p></li>
<li><p>The En Sof (Ein Sof): The En Sof is considered the highest level of reality, it is the realm of the Absolute, where everything is One, the realm of God himself.</p></li>
</ol>
<p>Note: In kabbalah, the ultimate goal is to attain an understanding of the highest level of reality, the realm of the En Sof, which is considered the ultimate truth and understanding of the universe. The layers of reality are considered as a ladder that one can climb, starting from the physical world, through the world of thoughts and imagination, to the world of pure intellect and finally to the realm of pure consciousness.</p>
<p>If we were to be honest with ourselves about what pure math actually is, according to the teachings of Kabbalah I think we would place pure math in the world of formation (Yetzirah). It might be tempting to place it into Briyah since we like to think of math as being "pure intellect" however as the famous mathematician GÃ¶del showed us almost 100 years ago, this is just not the case. </p>
<p>GÃ¶del's Theorem is a result in mathematical logic that states that in any formal system that is powerful enough to express basic arithmetic, there will always be true statements that cannot be proved within the system. This theorem was first proven in 1931.</p>
<p>In simple terms, GÃ¶del's Theorem says that any system that is powerful enough to express the basic concepts of arithmetic (like counting numbers) will contain some true statements that cannot be proven using the rules and axioms of that system. It means that there will always be some true mathematical statements that are beyond the reach of any mathematical system, no matter how powerful or consistent it is. This applies to any formal system, including the formal system of arithmetic, and it implies that there will always be some mathematical truths that are unprovable.</p>
<p>Another way to understand GÃ¶del's Theorem is that any system that is powerful enough to express arithmetic, will have limits in terms of what can be proven within that system, and there will always be some true statements that are unprovable.</p>
<p>A simpler way to think about the concept of "reality layers" is to come back to the concept that in pure math we can discuss the infinite in absolute terms. As far as we can prove (due to the Halting Problem) there is nothing in the entire physical universe (including the universe itself) that is truly infinite. </p>
<p>Wait a second, did I just say that the universe is not infinite? Not exactly. To be clear, I am saying that we can not <em>prove</em> that the universe is infinite due to the Halting Problem. The current scientific consensus is that the universe is infinite. This view is supported by several lines of evidence, including observations of the cosmic microwave background radiation, the large scale structure of the universe, and the accelerating expansion of the universe.</p>
<p>The cosmic microwave background radiation is the afterglow of the Big Bang, the event that is believed to have marked the beginning of the universe. Observing this radiation, scientists have been able to infer that the universe is homogeneous and isotropic on large scales, which is consistent with the idea of an infinite universe. The large scale structure of the universe also supports the idea of an infinite universe. Observations of galaxy clustering, for example, suggest that the universe is made up of an infinite number of galaxy clusters, each of which contains an infinite number of galaxies.</p>
<p>The accelerating expansion of the universe, which was first observed in the late 1990s, also supports the idea of an infinite universe. This acceleration is attributed to a mysterious force known as dark energy, which is thought to be causing the expansion of the universe to accelerate.</p>
<p>Note: Currently the scientific consensus is that the universe is infinite in size, but it's not infinite in age, as the Big Bang theory states that the universe started with a singularity and has a finite age.</p>
<p>The Planck length is a unit of length that is believed to be the smallest possible length that can be physically meaningful. It is named after the German physicist Max Planck, who first proposed the idea in 1899. The Planck length is approximately 1.616 x 10^-35 meters. This means that it's incredibly small, around 10^20 times smaller than the size of an atomic nucleus.</p>
<p>The Planck length is derived from three fundamental constants of nature: the speed of light, the gravitational constant, and the Planck constant. These constants are used to describe the behavior of matter and energy at the smallest scales. By combining them in a specific way, scientists have been able to calculate the Planck length, which is believed to be the smallest length that can be physically meaningful.</p>
<p>The Planck length is considered to be the "natural unit" of length at the Planck scale, which is the scale at which quantum gravitational effects are expected to become important. At this scale, the properties of space and time are thought to be fundamentally different from what we observe at larger scales, and the Planck length is thought to be the smallest possible length that can be physically meaningful.</p>
<p>All of this is to say that that "infinity" really can not exist in the physical reality we occupy. We can't keep going "up" or "down" forever. Things all things existing in physical reality are bound by some limit even if the limit is infinity itself (queue the Halting Problem). Since infinity can't exist in the real world, nothing in the real world can truly go on forever. Yet the scientific consensus is that the the universe <strong>does go on forever</strong>. How can this be? Godel has already given us the answer to this conundrum in the proof that "there will always be true statements that cannot be proved within the system". We are "in the system" of reality. Thus there will always be true statements about reality that can not be proven from within reality. In order to prove these things we would need to step out of the "reality layer" or "set".</p>
<p>Set theory is a branch of mathematics that deals with the concept of sets, which are collections of objects. The objects in a set are called elements or members, and the notation for representing a set is by enclosing its elements in curly braces {}.</p>
<p>For example, {1, 2, 3} is a set that contains the elements 1, 2, and 3. {a, b, c} is another set that contains the elements a, b, and c.</p>
<p>In set theory, we can also define sets using a rule or property that its elements must satisfy. For example, the set of even numbers can be defined as {x | x is an even number}, where the vertical bar "|" separates the set from the property that its elements must satisfy.</p>
<p>Set theory also allows us to perform operations on sets, such as union, intersection, and difference. The union of two sets is a new set that contains all the elements from both sets, while the intersection of two sets is a new set that contains only the elements that are common to both sets. The difference between two sets is a new set that contains the elements that are in the first set but not in the second set.</p>
<p>Set theory also defines some special sets, such as the empty set, represented by {} or Ã, which contains no elements. The universal set is the set that contains all the elements under consideration, and the subset is a set that contains only elements that are also in another set.</p>
<p>This sounds useful, but what about a set named "R" which contains all sets? The problem with set"R" is the issue of whether the set of all sets, also known as the "universe" or "absolute universe" of sets, exists. In set theory, it is generally assumed that there is a set "R" that contains all sets as its elements. However, this assumption leads to a paradox known as Russell's Paradox, first discovered by the philosopher and mathematician Bertrand Russell in 1901.</p>
<p>The paradox arises from the observation that if "R" exists, it must be a set, and thus must be an element of itself. However, if "R" is an element of itself, then it is not an element of itself, and vice versa. This creates a contradiction, and it is not possible to determine whether "R" is a member of itself or not.</p>
<p>This paradox led to the development of several theories in set theory, such as Zermelo-Fraenkel set theory, which attempts to resolve the paradox by introducing a hierarchy of sets, where a set can only contain sets that are "smaller" than itself. Another approach is the Von Neumann-Bernays-GÃ¶del set theory which introduces a distinction between sets and classes, where classes are not sets and do not belong to any set.</p>
<h2 id="theodyssey">The Odyssey</h2>
<p>Consider a fictional novel like The Odyssey. The characters and stories in this book originally existed in the mind of the author "Homer". Homer transferred the ideas (allegedly with the help of a Muse) to this book. This book can be thought of as a set that contains all of the information in the story of "The Odyssey". However, can you say that the book called "The Odyssey" contains the the book called "The Odyssey"? I will leave this exercise to the reader. </p>
<p>To continue with this thought, consider that when you read the book you are existing in the set we will call "base reality" while the characters and events in the book are contained to their own reality (which we call "The Odyssey") which is bound  by the covers of the book (no pun intended). The characters in the book can not possibly be aware of any information that exists outside the reality of this book. However, we as the reader, can be aware simultaneously of our own reality as well as the reality contained in this book. We can know things the characters can not, and if we read ahead, we can even know things about their reality they they don't. As the story progresses, new events unfold and the characters learn new things about their reality. The characters are bound by the fourth dimension of their reality, which is time (just as it is in our reality). But we the readers are not bound by the fourth dimension on the context of their reality (only our own). Think about how this concept applies to a story that is being narrated by an omnipotent narrator. </p>
<p>Much like Odysseus, we are bound by the linear progression of time (the 4th dimension) within our own reality. But it is not impossible to imagine that in a "higher" dimension, observers of our reality might not be bound by the same constraints. In the same way that we can flip to any page we wish and see what is happening at that point in the book, observers in a higher dimension would likely be able to view our reality in ways that are incomprehensible to us. </p>
<h2 id="flatland">Flatland</h2>
<p>"Flatland" is a satirical novella written by Edwin Abbott Abbott in 1884. It is set in a two-dimensional world, called Flatland, inhabited by geometric shapes such as squares, triangles, and circles, who live their lives within the constraints of their two-dimensional existence. The story is told from the perspective of a square, who serves as the narrator and protagonist.</p>
<p>The premise of the novella is to explore the limitations of perception and understanding that come with living in a limited-dimensional space. The inhabitants of Flatland, who are two-dimensional shapes, are unable to perceive the third dimension, and they are unable to understand or even imagine the concept of a third dimension.</p>
<p>Throughout the story, the square encounters a series of events that challenge his understanding of the world and lead him to question the nature of reality. He encounters a sphere, who is able to move in and out of Flatland, and is able to see and understand the third dimension. The sphere tries to explain to the square the existence of the third dimension, but the square is unable to fully comprehend it.</p>
<p>Note: The story also serves as a commentary on societal issues such as class and gender, as the inhabitants of Flatland are divided into classes based on their shape, and the female inhabitants are represented as straight lines, which are seen as inferior to the male inhabitants.</p>
<h1 id="thesims">The Sims</h1>
<p>In the video game "The Sims," players control virtual characters called "sims" in a simulated world, where they can control various aspects of the sims' lives such as their career, relationships, and daily activities. The sims are part of a larger set called "The Sims" which is the overall game or simulation.</p>
<p>Due to the fact that the sims are part of this simulated world, they can never be aware of what is happening outside of the simulation. They are limited by the parameters and rules of the game and are not able to perceive or understand anything beyond the simulated world.</p>
<p>For example, a sim cannot be aware of the fact that they are part of a video game, they cannot be aware of the player controlling their actions and decisions, they can't be aware of the real world and the people playing the game, they can't be aware of the fact that they are not real entities but rather a set of data and code.</p>
<p>In this sense, the sims are confined to their simulated world and can only exist and experience what is within the parameters of the game. They are not able to transcend the boundaries of the simulation and exist independently of it.</p>
<p>This may lead you to deeply question the nature of our own reality. If you find yourself here, know that you are in good company. </p>
<h1 id="allegoryofthecave">Allegory of the Cave</h1>
<p>Plato's "Allegory of the Cave" is a story found in his work "The Republic," which is intended to illustrate the nature of reality and human understanding. The allegory is presented as a conversation between Plato's teacher Socrates and one of his followers, Glaucon.</p>
<p>The story goes like this: there is a cave where a group of people have been chained since birth, facing a blank wall. Behind the people, there is a fire, and between the fire and the prisoners, there is a raised walkway with puppeteers who hold up puppets that cast shadows on the wall in front of the prisoners. The prisoners, who have never seen anything else, believe that the shadows on the wall are the only reality.</p>
<p>One day, one of the prisoners is freed and is able to turn around and see the fire and the puppeteers for the first time. As he becomes accustomed to the light, he realizes that the shadows on the wall are not reality, but only a representation of it. He then leaves the cave and goes out into the world, where he sees the sun, the stars, and other natural phenomena. He realizes that the cave and the shadows were just a poor imitation of the true reality.</p>
<p>When he returns to the cave, he tries to tell the other prisoners about his newfound knowledge, but they do not believe him and mock him for his strange beliefs. They are unable to see the truth because they are too used to their own limited perception.</p>
<p>The allegory is used to represent the human condition, where people are trapped in their own limited understanding of reality and are unable to see the truth. It also highlights the importance of education and the power of knowledge in allowing individuals to transcend their own limitations and understand the true nature of reality.</p>
<h1 id="setsofreality">Sets of reality</h1>
<p>We can think of the layers of reality defined by Kabbalah as being "sets" of reality. This may be an uncomfortable thought, but we need to start thinking about "realities" in the plural as opposed to one absolute reality. </p>
<p>To reiterate, the first 3 layers of reality according to Kabbalah are as follows:</p>
<ol>
<li><p>The world of action (Asiyah): This is the physical world we live in, where everything is measurable and observable. It is the realm of the five senses and is considered the lowest level of reality.</p></li>
<li><p>The world of formation (Yetzirah): This is the realm of thoughts, emotions, and imagination. It is the world of ideas, where things take shape and form. It is the realm of the mind and imagination.</p></li>
<li><p>The world of creation (Briyah): This is the realm of pure intellect, where concepts and ideas are created. It is the world of pure intelligence and understanding.</p></li>
</ol>
<p>There is the "base reality" I mentioned before (Asiyah) in which our physical selves exist. This is the only realm in which our physical selves (an thus our senses) can exist. Because of this, we can not use our senses to perceive anything that exists in any other reality (Imagining or remembering a scent is not the same as smelling it in physical reality). Additionally, since any form of measurement or quantification we want to take on a reality requires at <em>least</em> one of our senses to to be operating in that reality, we can not effectively know anything empirical about a reality aside from the base reality that our physical senses operate in.</p>
<p>That being said we (our non-physical selves, our minds) can venture into other realities on some level. When we imagine a alien star ship flying through space or a unicorn galloping across a plain, we are venturing into another reality. When we think of pure math, we are thinking on a level that exists outside of the physical reality that our bodies occupy. In this reality, anything is possible (even infinity). </p>
<p>Note: Now that we have discussed GÃ¶del's Theorem (but before we have even discussed number theory), we can (hopefully) agree on which set pure math should be placed in (Yetzirah), we can think about the idea that it exists at least one "reality layer" above our physical reality. By doing things like physical computing, we are inherently transposing the concepts of pure math into into physical reality which has inherent limits.</p>
<h2 id="numbertheory">Number Theory</h2>
<p>However, to take measurements of realities in which we have no physical senses, we must invent constructs that exist in those realities. One example of such a construct is something you are likely very familiar with: The "number".</p>
<p>Consider an apple. One single apple. Lets say that between Achilles and Bia, we they have only one apple but each of them would like to eat an apple. A solution could be for Achilles to whip out his sword and cut the apple in half. So now they have 2 halves of one apple right? Or do they now have 2 "half apples". What I mean, is that you can think of the result of the "cutting operation" as leaving you with either 2 halves of a single apple, or as leaving you with 2 individual and independent "things". We could probably use a more formal definition of "things" if we want to talk about this further, so we can call them "objects" or "sets". I will use the two terms interchangeably from here on. </p>
<p>Number theory is a branch of mathematics that deals with the properties and relationships of numbers, particularly integers. Number theory is often used to explore the concept of unity and plurality, and the relationship between them.</p>
<p>The question of whether an apple that has been cut into two parts is actually two independent objects or if it is really two halves of the same object is related to the concept of unity and plurality. In number theory, unity refers to the idea of a single, indivisible whole, while plurality refers to the idea of multiple, distinct parts.</p>
<p>In the case of the apple that has been cut into two parts, one could argue that the two parts are independent objects, as they are separate and distinct from one another. They can be moved, examined, and interacted with separately. This is an example of plurality.</p>
<p>On the other hand, one could also argue that the two parts are still two halves of the same object, as they were once a single, whole apple before they were cut. They are still connected by their shared history, and they still retain the properties and characteristics of an apple. This is an example of unity.</p>
<p>In number theory, this concept of unity and plurality is often explored in the context of numbers and their relationship to one another. For example, the concept of a prime number is based on the idea of unity, as a prime number is defined as a number that can only be divided by 1 and itself. On the other hand, the concept of a composite number is based on the idea of plurality, as a composite number is defined as a number that can be divided by other numbers besides 1 and itself.</p>
<p>Number theory, like many branches of mathematics, has a number of problems and paradoxes that have yet to be fully resolved. Some of the most well-known problems and paradoxes in number theory include:</p>
<ul>
<li><p>The Collatz Conjecture: Also known as the "3x + 1 problem," this is an unsolved problem that states that if you take any positive integer and apply the following rule: if it is even, divide it by 2, and if it is odd, multiply it by 3 and add 1, then you will eventually reach the number 1. The conjecture remains unproven.</p></li>
<li><p>Fermat's Last Theorem: This is a problem that states that there are no non-zero integers that can satisfy the equation x^n + y^n = z^n for any value of n greater than 2. It was first proposed by Pierre de Fermat in the 17th century and was not proven until the 1990s.</p></li>
<li><p>The Riemann Hypothesis: This is a problem that deals with the distribution of prime numbers. It states that all nontrivial zeros of the Riemann zeta function, which is a complex function that encodes information about the distribution of prime numbers, lie on the critical line of 1/2.</p></li>
<li><p>The Continuum Hypothesis: This is a problem that deals with the properties of infinite sets. It states that there is no set whose cardinality is strictly between that of the natural numbers and the set of real numbers.</p></li>
<li><p>The Banach-Tarski paradox: This is a result in set theory that shows that it is possible to decompose a solid ball into a finite number of pieces, and then reassemble those pieces into two identical copies of the original ball. This result is paradoxical as it seems to violate the basic principles of conservation of volume.</p></li>
</ul>
<p>These are just some of the known problems and paradoxes in number theory, but many more exist and many more will be discovered as the field progresses. These problems and paradoxes often challenge the current understanding of numbers and their properties, and they continue to inspire new research and discoveries in the field of number theory.</p>
<p>Numbers are a human invention that are used to represent quantities of things in the world. They are a way for humans to quantify and measure things in the world, such as time, distance, and weight. They are a way for humans to bridge the gap between the abstract and the real world, by giving names and symbols to quantities that can be used to communicate and understand the world around us. Numbers and mathematical operations can even be used to make predictions and understand patterns in the world (which are even occasionally useful).</p>
<p>Carl Sagan once said "We are a way for the cosmos to know itself", and in the same vein, numbers are a way for us to understand the world around us. But just like our understanding of the cosmos is limited by the tools and perspective that we have, numbers are also a limited tool for understanding reality.</p>
<p>It is deeply important to understand this so I will reiterate: Numbers are a human invention, a construct that we have created to quantify and measure the world around us. They are a powerful tool that allow us to communicate, predict, and understand patterns in the world. But numbers are an abstraction, a representation of the world and not the world itself (they are not <em>of this world</em> for that matter).</p>
<p>As we look to the universe, numbers are a useful tool, but they are not the universe. The universe is vast and complex, and numbers, no matter how precise, can only provide us with a glimpse of the grand tapestry of reality. Numbers are an imperfect bridge between the abstract and the real world, and while they are powerful, we must always be mindful of their limitations.</p>
<p>Just as when we look at the stars, we must remember that the light that reaches us is a representation of the reality, so too are the numbers we use to understand the world. They are a powerful tool, but we must always be aware of their limitations and not mistake them for the reality itself.</p>
<h2 id="measuringtheinfinite">Measuring The Infinite</h2>
<p>There are an infinite number of numbers between 1 and 2 because the set of real numbers is infinite and dense. In other words, between any two real numbers, there is always another real number.</p>
<p>One way to understand this is through the concept of decimal expansions. Every real number can be represented as a decimal expansion, with either a finite or infinite number of decimal places. For example, 1.5 can be represented as the decimal number 1.5, and 1 can be represented as the decimal number 1.0.</p>
<p>Between 1 and 2, there are an infinite number of decimal numbers that can be written, such as 1.1, 1.01, 1.001, 1.0001, and so on. These numbers are between 1 and 2, but they are distinct and different from both 1 and 2. Additionally, there are irrational numbers, such as the square root of 2, which can't be expressed as a ratio of two integers, and which also can be found between 1 and 2.</p>
<p>Therefore, we can say that there are an infinite number of numbers between 1 and 2, as the set of real numbers is infinite and dense, and there is always another real number between any two real numbers.</p>
<p>So how can we possibly count from 1 to 2 if there are an infinite amount of steps in between? </p>
<p>To measure the infinite, we simply need a way to make the infinity finite. If I recall correctly, we have done this at least once before when we solved Zeno's "Achilles Paradox". </p>
<p>The solution to Zeno's paradox was based on the concept of the limit, and the idea that the infinite sequence of intermediate steps can be thought of as a mathematical construct, rather than a Truth of our physical reality.</p>
<p>We can apply a form of this solution simply be recognizing that we have a known limit to our infinity. We know that the infinite set of numbers between 1 and 2 <em>must</em> end at 2. So simply by knowing where this infinite set ends, we can skip right to that point and effortlessly count from 1 to 2 with only 1 step as opposed to infinite. We can apply this same method to count between 1.1 and 1.2 (which is also an infinitely large gap) because we know the limits of the set between 1.1 and 1.2. In this same way, we know that Achilles is in fact able to complete his race since we have defined a limit (the finish line). Because of this, we know that movement and change is in fact possible in our physical reality.  </p>
<p>The secret to measuring the infinite really is just to define its limits. This does not actually mean that the set stops being infinite, it just means that the set has a beginning and an end. There can still be an infinite amount of intermediate steps. The properties of "being infinite" and "having a beginning and an end" are not mutually exclusive. This illustrates the nature of the bridge that numbers create between the abstract and the "real". Between the numbers 1 and 2 there are an infinite amount of steps, but there is also exactly one step if you know how to define limits. The idea that there are infinite steps but also exactly 1 step (even every number in between) is not inherently a contradiction. </p>
<p>But wait, does the set of numbers between 1 and 2 contain 1 and/or 2 themselves?  </p>
<pre><code class="hljs"><span class="hljs-attribute">1</span>.<span class="hljs-number">999999999</span>... = <span class="hljs-number">2</span>
</code></pre>
<p>The statement above is true.</p>
<p>This can be explained using the concept of limits. A limit is a value that a function or sequence "approaches" as the input or index gets closer and closer to a certain value.</p>
<p>In this case, the sequence of numbers 0.999999999 (ad-infinitum) is a decimal representation of the number 1, where an infinite number of 9's are placed after the decimal point. As the number of 9's increases, the value of the number gets closer and closer to 1, but never actually reaches it.</p>
<p>We can represent this sequence using the following mathematical notation:
0.999999999 = 0.9999999999 = 0.99999999999 = â¦ = 0.99999999â¦</p>
<p>If we take the limit of this sequence as the number of 9's approaches infinity, we get the value 1.</p>
<p>This can be formally written as:</p>
<pre><code class="hljs"><span class="hljs-attribute">lim</span> (<span class="hljs-number">0</span>.<span class="hljs-number">99999999</span>...) = <span class="hljs-number">1</span>
</code></pre>
<p>However, the set of numbers between 1 and 2 does not contain 2.</p>
<p>When we say "the set of numbers between 1 and 2", it is generally understood that the set includes all numbers greater than 1 and less than 2, but not including 1 or 2 themselves. This is known as an open interval and is denoted as (1,2) in mathematical notation.</p>
<p>To be more precise, (1,2) is the set of real numbers x such that <code>1&lt;x&lt;2</code>. The notation (1,2) indicate that the set does not include the endpoints 1 and 2.</p>
<p>Another way to understand this is that the set of numbers between 1 and 2 is the set of numbers that can be expressed as 1+x where x is a positive real number, because x is less than 1 which is the difference between 2 and 1.</p>
<p>So, the set of numbers between 1 and 2 does not include 2, it only includes the numbers greater than 1 and less than 2.</p>
<h1 id="fromtheabstracttothereal">From the Abstract to the Real</h1>
<p>In order to take an idea from the abstract reality into physical reality, we need to give it limits. For example, if we want to take our imagined spaceship and bring it into the physical world, we will need to decide what its physical properties (measurements) actually are. We could argue that we have already given the spaceship limits just by imagining it in the first place. After all, it is clearly distinct from the everything else you are imagining that is <em>not</em> the space ship (be it stars in the background or a "blank canvas"). So in this sense we have already given the space ship limits. We can create two clearly distinct sets within out imagination. One set that contains the spaceship, and another that contains everything in our mind <strong>but</strong> the spaceship (dont worry too much about the contents of this set). But, in order to create the spaceship set, we need to first define the limits of that set. Without limits the spaceship exists in the realm of pure, infinite, undefined possibility. </p>
<p>To think back to the layers or reality defined by Kabbalah, we might call the level where the spaceship exists before it was defined "Briyah". To recap:</p>
<ol start="3">
<li>The world of creation (Briyah): This is the realm of pure intellect, where concepts and ideas are created. It is the world of pure intelligence and understanding.</li>
</ol>
<p>By applying limits to Briyah, we can bring things out of it and into the second level of reality "Yetzirah":</p>
<ol start="2">
<li>The world of formation (Yetzirah): This is the realm of thoughts, emotions, and imagination. It is the world of ideas, where things take shape and form. It is the realm of the mind and imagination.</li>
</ol>
<p>From there, we need to define yet more limits so that we can get the space ship into our "base reality":</p>
<ol>
<li>The world of action (Asiyah): This is the physical world we live in, where everything is measurable and observable. It is the realm of the five senses and is considered the lowest level of reality.</li>
</ol>
<p>To do this, we can use a very useful tool that we have discussed before called "the number". In practice, we assign numbers (measurements) to the spaceship object that we have in Yetzirah which as we have discussed helps us bridge the gap between the abstract (Yetzirah) and our physical reality (Briyah). This process is known as "transposing". It is very similar to the music concept by the same name which means to take a set of notes centered around a given pitch and to move them up or down (in pitch) in a unified way that retains the structure of the set. </p>
<h1 id="transposingourspaceship">Transposing our Spaceship</h1>
<p>This might come in the form of drawing the ship onto paper, which also involves transposing into yet lower level of reality (the second dimension). It could also come in the form of building a physical replica of the ship. Maybe to scale, maybe not. </p>
<p>Regardless of the method of transposition that we use to get our object into the real physical world, unlike transposition in music where no data or structure is lost, there will always need to be additional limits put into place to transpose objects from a higher reality into a lower reality. </p>
<p>Let's say that we have already transposed the spaceship into physical reality. We made a 3d replica of it out of fabricated metal bits. It may be a rough approximation of the ship we had in our minds, partly do to our own technical ability in crafting the replica, but also due to the fact that we had to assign limits which did not exist before. Now let's say that we can to take it one step further and render our 3d spaceship model into a 2 dimensional drawing. In order to do this we must define even more limits. Our replica exists in 3 dimensions, but the paper can only hold 2. So in order to get the space ship onto the flat, 2d paper, we need to sacrifice a dimension. This concept is relatively easy to understand considering that both the 3rd and 2nd dimensions are "below us" (remember our physical reality exists in 4 dimensions. The 4th being time where as the model can be thought of as really only holding meaningful information in 3 dimensions). As a matter of fact, I'm sure any capable artist has experience transposing between the first and second dimensions. The point is that sacrifices must be made to do this, additional limits (like the removal of the 3rd dimension) must be implemented. </p>
<p>Its worth noting that there are 2 common ways to transpose an object from 3 dimensions into 2. </p>
<p>One way is to draw "blueprints" where the objects 3rd dimension is split (or "down sampled") into the 2nd dimension by means of N cross sections. This can make it possible to recrate (or create) a 3d object but it is important to notice that data is still being lost since we must down sample the 3rd dimension. We can not take a continuous dimension and split it into discrete parts without losing information. We would need an infinite amount of cross sections to avoid losing information, and creating infinite cross sections of the 3rd dimension would essentially be recreating the dimension itself. I think it likely (but possibly not provable) that a dimension can not exist within a dimension in which it does not currently exist.</p>
<p>The other way in which we could go from 3 dimensions to 2 is to take a more artistic approach. Considering this approach can also further our understanding of dimensional transpositions. An artist who is more concerned with capturing the "essence" of the objet may chose to employ a different means of transposing the object. They might use a technique known as a skeuomorph, a derivative object that retains ornamental design cues from structures of the object in the higher dimension but does not necessarily contain all the information contained in the higher object. If you imagine an artistic 2d drawing of a 3d spaceship, you are probably imagining a skeuomorph. Another common example skeuomorphism is the user interface design found on many modern computing devices such as the iPhone. 3d buttons do not actually exist inside your phone screen but the interface designers have used skeuomorphism to retain the import features of the object that make it seem 3d to our brains. Things like shading on edges and shadows that cause the illusion of depth. We can also consider a photo of a real 3d object. The photo is essentially a skeuomorph, it has preserved the qualities that make us understand that the object "exists in the 3rd dimension" without the photo actually being 3d. It is very important to understand that dimensions can have the illusion of containing other higher dimensions when they in actually do not. Even a 3d model rendered in real-time on a computer is just an ever changing series of skeuomorphs. As a matter of fact, if you do deep enough, the 3d model (or a digital photo) for that matter is not even a truly 2 dimensional object. In reality computer memory only has 1 dimension. It is just a very, very long list of bits. </p>
<h2 id="howcanweturnonedimensioninto2">How can we turn one dimension into 2?</h2>
<p>Consider the following set:</p>
<p>{0,1,2,3,4,5,6,7,8,9}</p>
<p>This is a one dimensional set (as are all sets at their core). However, we might refactor the set into multiple sets like this:</p>
<p>{0,1,2,3,4}, 
{5,6,7,8,9}</p>
<p>By doing this, we have taken a 1 dimensional set and turned into 2 distinct one dimensional sets (or do we have 2 halves of one set?). It seems that all we have done is create 2 1d sets out of a single 1d set which is absolutely correct. However, we have now unlocked the ability to invent a new dimension. If this sounds like "mad science" bare with me, I assure you the world is not about to implode (or explode for that matter). </p>
<p>Consider the indices of the 2 sets, I will write the indices inside of brackets for clarity:</p>
<pre><code class="hljs">[<span class="hljs-number">0,1,2,3</span>,<span class="hljs-number">4</span>]
{<span class="hljs-number">0,1,2,3</span>,<span class="hljs-number">4</span>},

[<span class="hljs-number">0,1,2,3</span>,<span class="hljs-number">4</span>]
{<span class="hljs-number">5,6,7,8</span>,<span class="hljs-number">9</span>}
</code></pre>
<p>Before with our 1d set we could only move "left" or "right" within the set. If we are at 2 we can move right to 3 or left to 1 but we can not move in any other directions. </p>
<p>The indices are the key (pun indented) to traversing between the 2 individual sets. To make discussing these sets easier, lets give the sets the names "A" (for the first set) and "B" for the second. With the power of indices, we can draw connections between the 2 sets. </p>
<p>Now, if we say that set B is "down" from set A and set A is "up" from set B, we can start moving in 2 more directions. This giving us a starting point to think about our 1 dimensional set as being 2 dimensional. In other words, by creating limits on the 1 dimensional set we can actually simulate an entirely new dimension. </p>
<p>We can formalize this idea a bit by thinking again of the original 1d set:</p>
<p>{0,1,2,3,4,5,6,7,8,9}</p>
<p>By adding rules to the way we think about this set, we can "create" new dimensions. But what exactly are those rules? To define the rules, we will think about the 1d set as only existing in the dimension "X" and the 2d set as existing in dimensions "X" and "Y". </p>
<p>Futhermore, to define these rules we must also define limits to the new dimensions. These limits can be called "W" for width, and "H" for height. Since we know that our original set has a finite amount of elements (10) we must be sure that any new dimensions that we create are do not contain (in total) more than 10 elements. So by this logic we can say that we could have 2 dimensions that contain 5 elements each, or we could say for instance that X contains 3 elements and Y contains 2. While these unused elements might go to waste, we do not need to be sure we contain <em>exactly</em> 10 elements but we <em>must</em> not include more than 10 (or or set can not contain the new dimensions). </p>
<p>To formalize the limits of our new dimensions we could say:</p>
<pre><code class="hljs"><span class="hljs-attribute">W</span> * H &lt;= <span class="hljs-number">10</span> 
</code></pre>
<p>Or if we were to define the amount of elements in the set as "Z" we could simply say:</p>
<pre><code class="hljs"><span class="hljs-keyword">W</span> * H &lt; <span class="hljs-keyword">Z</span> + <span class="hljs-number">1</span>
</code></pre>
<p>Note: The "&lt;=" operator means "less than or equal to". The expression <code>Z + 1</code> is another way of stating this same logic.</p>
<p>We can apply a very similar rule to the size of the 2 dimensions themselves. We could say:</p>
<pre><code class="hljs"><span class="hljs-keyword">X</span> * <span class="hljs-keyword">Y</span> &lt; <span class="hljs-keyword">Z</span> + <span class="hljs-number">1</span>
</code></pre>
<p>Futhermore, we can apply <em>similar</em> (but not identical) logic to the size of the 2 sets we created "A" and "B". </p>
<pre><code class="hljs"><span class="hljs-selector-tag">A</span> + <span class="hljs-selector-tag">B</span> &lt; Z + <span class="hljs-number">1</span>
</code></pre>
<p>Note that here we are concerned with <code>A + B</code> and not <code>A * B</code>. This is because the other two rules concerned a 2 dimensional concept known as area, whereas sets A and B are both 1 dimensional thus the concept of area does not apply (instead we have "length" or size). It is also worth noting that we have just created several rules which are effectively comparing 2 dimensional objects with 1 dimensional objects without any loss of information. This is possible because we have created the second dimension as a construct of the first.  </p>
<p>However this begs the question of how it is possible that a set can contain a dimension that didn't already exist in that dimension. After all, I said before that I think this is impossible. We are dealing with lots of contradictions here, but am I contradicting myself? The answer is yes, and no (yet another contradiction). To clarify, I would argue that the 1 dimensional set in many ways, already contained the additional dimension (or at least contained the potential for it to exist). That being said, it is very important to recognize that the only way in which we can create new dimensions is by "slicing" the set which contains that dimension into multiple smaller sets. These smaller sets are called "subsets". </p>
<pre><code class="hljs"><span class="hljs-attribute">P</span>: {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>}

<span class="hljs-attribute">A</span>: {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}
<span class="hljs-attribute">B</span>: {<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>}
</code></pre>
<p>In the above example, sets "A" and "B" can be thought of as subsets of the parent (or superset) "P". All of the data contained (an all of the capacity for data) in sets A and B is contained in set P. We must then ask if set P can simultaneously contain subsets A and B but also still be itself. The simple answer is yes. Set "P" can contain sets A and B in the above example without losing its original identity (data). So with this in mind it is possible for the 1 dimensional set P to contain 2 dimensions within it, so long as those 2 dimensions only consist of the original data in set P. </p>
<p>But what if we want to use set P to simulate another dimension as opposed to just "pretending" to have one? There is no way I can think in which set P can contain 2 dimensions (subsets) that only contain the original data of set P but also include meaningful data about dimensions that are not originally contained in the data of set P. Consider that a dimensional set can never contain any "extra"/"empty" data. On any axis, at any point, there is either something or nothing, both of which are equally meaningful and important. Because there is no "exta" data to be found in a dimensional set, there is no where to store new data, even if we were to notice that the data in the set is "all empty" after point N it is still a critical part of the dimensional set, filling in this space with data from another dimension will lead to an inherent loss of data in the parent dimension. So, due to the fact that dimensions do not have any empty space for us to fill in, it is in truth not possible to create new dimensions within an existing dimension without sacrificing part of that dimension. </p>
<p>Consider this example:</p>
<p>P: {0,1,2,3,4,5,6,7,8,9}</p>
<p>A: {0,1,2,3,4}
B: {5,6,7,8,9}</p>
<p>If we wanted to create meaningful data about dimension Y in a data set that is already full of data about dimension X we must sacrifice some data that we have about dimension X. Without doing that, we can pretend to have a second dimension but we really only have X. </p>
<p>We might sacrifice some data like this:</p>
<p>P: {0,1,2,3,4,-1,-2,-3-,-4}</p>
<p>A: {0,1,2,3,4}
B: {-1,-2,-3-,-4}</p>
<p>Unless an object is self-similar across multiple dimensions, we will always need different datasets to talk about new dimensions which means we will always need to sacrifice some data to in our current dimension to do that. </p>
<h1 id="occupiedandemptydimensions">Occupied and Empty Dimensions</h1>
<p>We call the dimensions that exist in our physical reality, X,Y,Z and T. Z bing the third dimension (depth) and T being time. These 4 dimensions are already full to the brim with objects (subsets). Even though each of these dimensions seems to go on ad-infinitum, they are still somehow full to the brim with data. We can change the data via physical action (or sometimes inaction) but we just do not have any more room for new data that does not replace some old data. One this note, it's worth pointing out that in general, objects that exist in higher realities / dimensions can very rarely (if ever) cause change in lower sets without first entering that set on some level. Consider that an an idea can not change the world, only the implementation of that idea (through action or sometimes inaction) can cause change in the physical world. </p>
<p>The good news is that computers, like pure math, give us the ability to work with truly empty sets and dimensions (which would case a paradox in physical reality by simultaneously existing and not existing). So lets take advantage of that now and think about how we can turn an empty one dimensional set into a 2d set without loss of data. Keep in mind though that this is only possible because we are starting with a truly empty set, one that does not meaningfully exist until we populate it with data. This empty set <em>does not</em> represent a dimension in and of itself. It is much more similar to the 3rd level of reality described by Kabbalah which as a reminder is:</p>
<ol start="3">
<li>The world of creation (Briyah): This is the realm of pure intellect, where concepts and ideas are created. It is the world of pure intelligence and understanding.</li>
</ol>
<p>The first step to working with this empty set is to define it's limits. An empty set by definition, does not have a beginning or an end. If it did, the beginning would be the end, which does not do anything particularly useful for us (no more useful than a set which is uncountable do to its infinite nature). For all intents and purposes, an empty with a size of zero and an empty set with a size of infinity, are equal (if at all possible). By assigning limits to our theoretical empty set, we can begin to bring it into the second layer of reality known as Yetzirah. To recap:</p>
<ol start="2">
<li>The world of formation (Yetzirah): This is the realm of thoughts, emotions, and imagination. It is the world of ideas, where things take shape and form. It is the realm of the mind and imagination.</li>
</ol>
<p>Now we have an set of size "Z" that contains only empty values. But "empty" in this context is not a tangible, quantifiable concept so it can't exist our physical reality. We must define "empty" with some construct that can exist here. A useful definition that is used quite often is the number zero. So lets say that all our empty items contain the number 0. </p>
<p>So lets define an empty set with a size of 10. This will look a lot like the sets we have defined before. It is one dimensional. However since this dimension does not contain any data from any pre-existing dimension, we can call it whatever we want. Lets call it "G". </p>
<pre><code class="hljs"><span class="hljs-attribute">G</span> = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}
</code></pre>
<p>So now we have an empty dimension (with bounds) that can contain whatever kind of data we want it to. Its a blank canvas (but not an infinite canvas). We could use it to store one dimensional data, like a set of square numbers:</p>
<pre><code class="hljs"><span class="hljs-attribute">G</span> = {<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>,<span class="hljs-number">128</span>,<span class="hljs-number">256</span>,<span class="hljs-number">512</span>,<span class="hljs-number">1024</span>}
</code></pre>
<p>Now we might call "G" the "square number dimension" since it is used to represent information about which numbers are squares. This is similar to the way we call the third dimension in our physical reality "depth" because it contains information about the an objects "depth".</p>
<p>However, this is not what we set out to do. We want to use this empty single dimension to create 2 new dimensions. That can get messy. To keep things as simple as possible, we will call the items in our set "cells". And from now on we will say that our cells can either be empty (0) or full (1). We can also think of the cells as being "on" or "off". </p>
<p>We have already covered the basics of going from a one dimensional set into 2 dimensions, so let's do that again, but this time with out empty set "G".</p>
<pre><code class="hljs"><span class="hljs-attribute">G</span> = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}

<span class="hljs-attribute">A</span> = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}
<span class="hljs-attribute">B</span> = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}
</code></pre>
<p>So far so good, but we didn't really create any new dimensions here, we just created 2 subsets. So create dimensions, lets once again consider the power of indexing. </p>
<pre><code class="hljs">    <span class="hljs-section">[1,2,3,4,5]</span>
<span class="hljs-attr">A</span> = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}
    <span class="hljs-section">[1,2,3,4,5]</span>
<span class="hljs-attr">B</span> = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}
</code></pre>
<p>So now we can go "up" and "down" again in addition to going "left" and "right". It is important to understand that sets A and B are not dimensions themselves and we can not make them into dimensions. They are just 2 one dimensional sets. The indices are what allow us to move between dimensions and they are essentially the source of the dimensionality itself. To illustrate, let's go ahead and turn this into a matrix. A matrix is a rectangular array (set) of numbers, symbols, or expressions, arranged in rows and columns. Matrices are often used to represent and manipulate linear equations and systems of linear equations. They can also be used in a wide range of mathematical and scientific applications, such as in linear algebra, statistics, and computer graphics. The closest thing to our application here is here is computer graphics. When discussing matrices, it is important to understand that they are also mathematic constructs. They do not "actually exist" they are simply an abstraction on top of sets that let us work with multiple dimensions more easily. We could turn our set into a matrix like this:</p>
<pre><code class="hljs"><span class="hljs-attribute">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,
<span class="hljs-attribute">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>
</code></pre>
<p>Notice the training comma on the first row, this shows that we are still in fact working with a single 1 dimensional set. The only difference between this matrix and the set "G" is that we have chosen to illustrate it in a rectangular fashion. Nothing about the set has changed. We can think of the two rows of this matrix as being the subsets of G that were defined as "A" and "B". </p>
<p>We could illustrate how this allows us an easy way to map 1 dimension into two as follows:</p>
<pre><code class="hljs">| <span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0</span>,
y <span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0</span>
  x--------
</code></pre>
<p>However, in computer graphics it is customary to treat the origin as being in the top left. Moving forward, I will follow this convention. For example in computer graphics, we would draw the X and Y axis like this:</p>
<pre><code class="hljs">  x--------
y <span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0</span>,
| <span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0</span>
</code></pre>
<p>To the top left cell is has the coordinates 0,0 as opposed to what you may have expected (0,1). It is also worth mentioning that another convention of computer science in general is to count from zero. This is another convention I will follow moving forward. </p>
<h1 id="setsareusuallynotdimensions">Sets are (usually) not Dimensions</h1>
<p>One very interesting property of this system that you might have noticed is that both sets A and B contain data from both dimensions (x and y). As I mentioned before, the subsets A and B are not the dimensions themselves. They merely enable the dimensions to exist within our set. it would not be possible to define 2 sets in a 2 dimensional system that only contain one dimension each (assuming the 2 dimensions are related in some way i.e. perpendicular to each other). The ability to have multiple dimensions is an emergent property of creating the subsets but the actual dimensionality is a function of the relationships between the values in these sets according to their assigned indices. In this way, we can think of the sets of indices (we have 2 now, x and y) as being sets of their own. However, these 2 sets of indices <strong>are absolutely not contained in set "G"</strong> which means they are not subsets of set G. These sets are emergent properties of of set G which were manifested by defining limits of the subsets within set G. These sets rely on more than the set G to exist, in order for them to exist need to know the width and height of our matrix which is not data that exists anywhere in set G. The sets of indices are dependant on "metadata" (data which exists outside of the set but describes the set). Because of this we can describe these sets of indices as being "meta-sets" to the set of "G". We can also say that set G itself has an implicit metaset to it which is the index of items in the set G. This set would contain the natural numbers (integers) from 0 to 9.</p>
<p>Now that we have our matrix, we need some rules to describe how we can talk about a cell (item) in set G in terms of its coordinates in the matrix (X,Y). It would also be helpful to have a way to talk about a set of coordinates in terms of its index in set G. We will call the index of set G "N" and the coordinate set of x and y as simple "X" and "Y". We will call the width of our matrix "W" and its height will be "H". </p>
<p>First of all, we can need to understand that as long as we are expressing our rules as mathematical formulae, we can only ever return return (solve for) on value at a time. Because of this we can not write a rule that returns the X and Y coordinates at the same time. With that in mind, lets see how we can get from N to X and Y:</p>
<pre><code class="hljs"><span class="hljs-attr">X</span> = N % H
<span class="hljs-attr">Y</span> = N / W
</code></pre>
<p>These formulae are pretty simple but there might be a few things I need to clarify. First, if you are not a programmer, you might not be familiar with the "%" or "modulo" operator. This works by first preforming a division operation <code>N / H</code> but instead of concerning itself with the direct result of that operation, it is interested in the remainder or "modulus" of the operation. So the expression <code>7 % 2</code> would result in a value of 1 because after dividing 7 into 3 equal parts of 2 each (or 2 equal parts of 3 each for that matter), we have a remainder of 1. </p>
<p>The second thing that may need some clarification is that since we are working on a matrix that has only whole number indices, numbers which are not natural (decimals or fractional numbers) can not exist. Thus the result of the operation <code>7 / 2</code> would result in a value of 3 as opposed to 3.5 since the ".5" can not exist and 4 x 2 is greater than 7 which would put it "out of bounds". This might beg the question about whether we are losing information here. The answer is once again yes and no. If you are thinking about the rules from within the context of set "G" which only has whole number indices or you are thinking in terms of the matrix which also has only whole number indices, then no data is truly lost. Since that data cannot exist in these systems, it is effectively meaningless. However, if you are observing this set from another outside set (another reality) in which we accept that decimal numbers do exist then it seems obvious that data is lost. This may sound like a very hypothetical problem but it is at the core of digital computing and the discussion of discrete vs continuous mathematics. </p>
<h2 id="thinkinginblackandwhitebinarybooleansandbits">Thinking in Black and White (Binary, Booleans and Bits)</h2>
<p>A digital computer can only understand binary data, binary data can not encode continuous information (nor can any known digital data storage method). As we have discussed "real numbers" (whole numbers, decimals and fractional numbers) are infinite continuous sets and as we have discussed, we can not bring infinite continuous sets into reality (which digital computing is very much part of) without assigning them limits or bounds. Modern digital computers can do quite well at working with all sorts of real numbers now, but this is only because we have assigned them limits and we have down sampled them into a finite amount of states that exist within the computer (which is a finite set or "finite state machine"). However despite these clever limits and abstractions, computers still have problems thinking about fractional numbers. Consider the simple fraction <code>1/3</code> which can be expressed as a decimal like <code>0.333333...</code> the ellipsis at the end of the decimal means that the 3's should continue into infinity. This is a clear problem for any system which does not have an infinite amount of storage space to store such a number. </p>
<p>One way that we can avoid the inherent problems that digital computers face when dealing with fractional numbers is to avoid digitization all together. In the past we used computers which could operate on continuos data. These computers were known as "analog" as opposed to digital. Early versions of analog computers did not involve any kind of electricity at all. They instead were purely mechanical consisting of "cams" and gears.    </p>
<p>In the context of mechanical computing, "cams" refer to a mechanism used to convert rotary motion into linear motion, or vice versa. A cam is typically a cylindrical or disk-shaped piece of metal or other material that has a specially shaped profile on one or more of its surfaces. As the cam rotates, the profile comes into contact with a follower, which is a lever or other mechanical component that moves in response to the cam's motion.</p>
<p>The shape of the cam's profile determines the type of motion that the follower will experience. For example, a cam with a simple circular profile will cause the follower to move in a circular path, while a cam with a more complex profile, such as an eccentric or a lobed shape, can be used to generate more complex motions. Cams are often used in mechanical systems such as engines, clocks, and machinery to convert rotary motion into linear motion, to control the timing or duration of an event, or to change the position of a component.</p>
<p>A "square root cam" would be a cam that has a profile shaped like the square root function on its surface (transposed from a 1d number line to a 2d matrix of physical atoms known as XY in physical reality). A square root function is a mathematical function that returns the square root of a number, which is the number that, when multiplied by itself, gives the original number.</p>
<p>When this cam rotates, the follower that comes into contact with the square root cam profile would be moved in a non-linear motion, that is, a motion that follows the square root function.</p>
<p>The follower would move along the edge of the square root cam profile, in the direction of the rotation of the cam. The motion would be such that the follower would move slower as it approaches the peak of the square root function and then faster as it moves away from the peak.</p>
<p>A square root cam would be used in mechanical systems that require a non-linear motion, or in situations where the rate of motion needs to be slowed or speeded up in a specific non-linear way.</p>
<p>While it may appear that this system is fully continuous and infinite it is in fact not. This is due at the very core to the existence of the Planck Length (which removes the possibility of truly continuous systems from physical reality), but in more practical terms we can think of the the limitations as a function human engineering and material sciences. Additionally, most complex systems implementing cams also implemented toothed gears with are indented to be deceit by their very nature.  </p>
<p>After we ran into the limitations of mechanical computing, we moved into the real of analog electronic computing. Early electronic computers were capable of storing data in the medium of vacuum tubes. Vacuum tubes, also known as electron tubes, were electronic devices that were widely used in the early days of computing and electronics. They were used to store data by controlling the flow of electrons through a vacuum-sealed glass or metal container.</p>
<p>One of the most common ways vacuum tubes were used to store data is through the use of a cathode ray tube (CRT). A CRT is a vacuum tube that contains an electron gun, a focusing system, and a phosphor-coated screen. The electron gun generates a beam of electrons, which is focused onto a specific point on the screen by the focusing system. The electrons then strike the phosphor-coated screen, causing it to emit light.</p>
<p>By controlling the position and intensity of the electron beam, it is possible to "write" data onto the screen in the form of a pattern of illuminated dots or lines. This pattern can then be "read" by an operator or an electronic sensor.</p>
<p>Another way of storing data in vacuum tubes was by using the electronic memory called Williams tube. It used a cathode ray tube to store data by creating a charge on the surface of the tube. The charge was used to represent the state of a bit(0 or 1) and it could be read by an electronic sensor.</p>
<p>Vacuum tubes were eventually replaced by solid-state devices such as transistors and integrated circuits in most applications, due to their superior performance, reliability and cost-effectiveness. </p>
<p>At multiple points in the evolution of computing, we have given up a little bit of information for better performance. While nothing in physical reality is truly continuous by moving away from systems that were "almost continuos" into the realm of binary digitization, we have also given up any real hope of accurately working with anything besides whole numbers (integers). As I mentioned before the ability for modern computers to understand fractional numbers at all, is nothing but a clever abstraction on top of integers.   </p>
<p>In the world of digital computing, fractional numbers do not exist (but they are not entirely meaningless thanks to our abstractions). In much the same way, the result of 7/2 being anything aside from 3 withing the context of our matrix is meaningless and since the extra data can have no meaning in our matrix, its loss is also meaningless. In other words, in the reality of our matrix, saying that 7/2=3 is not only valid, but an objective truth about the reality in which our matrix resides. To prove this, simply try to find the value in "G" with the index <code>3.5</code>.  It is akin to looking for the house on your street with the address of "â³". No matter how long you look, you will never find it and that has very little to do with the Halting problem.</p>
<p>This is however related to the Achilles Paradox and the illusion of movement within our cellular automata simulation. Aside from the fact that the core rules of the simulation prevent a cell from "moving" it would be impossible for the cells to move within any rule set we define since the cell can not exist at the intermediary coordinates involved to facilitate movement. Movement is a continuos operation and within the terms of pure mathematics it can not occur in any amount of discrete steps. There will always be steps required between the discrete steps to get from discrete step A to discrete step B. </p>
<p>Consider an movie you are watching on your TV set. The characters on screen are not really moving, instead what you are seeing is an illusion of movement created by a quick succession of discrete states that follow the physical patters that our brains recognize as movement. If we were to slow down these discrete frames to a rate where less than 12 of them are displayed in succession every second (a frame rate of 12fsp or 12Hz) we would see the illusion break down and we would notice that we are not actually seeing motion at all. This is true for most people at frame rates of up to about 30Hz and for some individuals the movement can look unnatural in excess of 60Hz. </p>
<p>Another example of how our brains can be tricked into perceiving non-continuous systems as continuous is the method we use to dim LED bulbs. An LED bulb for most intents and purposes can only exist in 2 states, powered or un-powered, on or off. But if that's the case, how can we dim an LED? The answer is a technique known as pulse width modulation (or PWM). By switching states between on and off (oscillating) at a rate that is higher than what most humans perceive to be blinking (which is not coincidentally also about 30Hz) we can create what is perceived by the human eye (or really the human brain) as being a continuous "stream" of photons (light). </p>
<p>By increasing what is known as the "duty cycle", which is the ratio of time in which the bulb is on vs when it is off, we can increase the brightness of the bulb. By setting a duty cycle of 1/2 (or 50%) we would have the bulb on half of the time and off the other half of the time. As long as this cycle happens at a rate of over ~30Hz we would see the bulb as being at half brightness. If the cycle speed dropped below 30Hz most people would only see a series of blinking. When the light blinks "on" it would be perceived as being at full brightness and when it blinks "off" it would be perceived as having no brightness at all. If we were to set the duty cycle to 100% we would see the full brightness of the bulb and at a duty cycle of 0% we would see no brightness of any kind. An oscillator with a duty cycle of 0% or 100% can also be inherently thought of as having a cycle speed of 0 because it does not actually cycle as there is only one state it can be in. We could say that this object is no longer <em>oscillating</em>. However, this does not inherently mean that the object is not still an <em>oscillator</em>. </p>
<h1 id="tryingagaintoprovestabilityvsinstability">Trying Again to Prove Stability vs Instability</h1>
<p>Oscillators can be either stable or unstable, depending on the specific system or mechanism involved.</p>
<p>A stable oscillator is one that is able to maintain its oscillations at a constant frequency and amplitude over time, regardless of small disturbances or changes in the system. The pendulum of a grandfather clock is an example of a stable oscillator.</p>
<p>An unstable oscillator, on the other hand, is one that is sensitive to disturbances or changes in the system, and may experience changes in frequency and amplitude over time. An example of an unstable oscillator is a child's swing. When you push a child on a swing, the oscillations become larger and larger, until the child is going very high.</p>
<p>In general, stability of an oscillator depends on the balance of forces that drive the oscillation and the forces that dampen it. For example, a pendulum oscillator is driven by gravity, and damped by air resistance.</p>
<p>In electronic circuits, the stability of oscillators can be achieved by using feedback control systems, where the output of the oscillator is fed back to the input, to maintain a stable amplitude and frequency.</p>
<p>It's also worth noting that an oscillator can be stable for certain range of parameters and unstable for others.</p>
<h2 id="cellsororganisms">Cells or organisms?</h2>
<p>Back to our cellular automata, how can we determine if an oscillating organism (object / set) is stable or unstable? To answer this question we must first define what exactly we want to understand the stability of. we need to formalize the difference between an organism and the population at large. </p>
<p>Set theory and number theory can help us conjure a workable distinction between the two. Earlier we asked if an apple that is shared between Achilles and Bia is in fact 2 distinct objects after it is cut or if it is really just 2 parts of the same apple. I think with what we have established so far, you would not think it unreasonable if I were to say that the apple is both 2 distinct objects, neither of which are the original apple, and also 1 distinct object split into 2 sets. To take this a step further, let us question where the "original apple" still exists after being cut into 2 parts, or if it has ceased to exist. Continuing with the pattern, we can say that both are true. The apple still exists because every atom that made up the apple (aside from the bits that ended up on Achilles' sword which we will ignore) also still exist and they are (once again ignoring the effects of the sword) in their original configuration. As long as the atoms in the 2 parts of the apple are still in the original configuration, the apple still exists (and can be made whole again) because no information that made up the apple has been lost. At the same time, we can also say that the apple no longer exists, if it does, where is it? Surely a single object (in physical reality at least) can not exist in 2 places at the same time, so if half of the apple in the the stomach of Achilles and half in Bia, then it would be a paradox to say the apple does't exist. However, if the apples doesn't exist anymore, how can we account for all of its data (its entire state) still existing? No matter which answer we chose, we create a paradox. Perhaps the solution that causes the least amount of headache is also the least intuitive, the apple exists and does not exist. Both statements being equally true in our physical reality. </p>
<p>This however is also a paradox, how can the apple exist but not at the same time? If we invert this and instead of saying both are true, we say neither statements are true, then we still have a paradox on our hands. It cant be false that the apple exists and also false that apple does not exist either. These statements are mutually exclusive in terms of formal logic. So maybe this is to say that the concept of the apple itself as being a distinct from the rest of the set (which is physical reality or even our imaginary reality since we are clearly not discussing a "real" apple) is a fallacy. Maybe the real false statement here is simply "the apple". Agreeing to that would certainly cut down on all these paradoxes we keep running into. </p>
<p>Creating any distinctions between cells (items) in a set is a construct prone to paradox. The absolute truth is that the concept of distinction does not exist withing a set. A set is in and of itself the only distinction that can be made. Sets can exist inside other sets and we can consider the barriers (bounds) between the subsets to be distinctions between the items in the superset. We can consider it to be that way but it is not in fact, that way. </p>
<h1 id="types">Types</h1>
<p>A set can only contain items of the same type. For example a set of all animals with fur, has the type "animal" and can not possibly contain anything that is not an animal. After all, if it were to contain something that was not an animal, like a peach, it would no longer be the the set of "all animals with fur" it would maybe be called the set of "all organisms with fur" and the type would no longer be animal but instead "organism". Following this logic, a set containing all cars I have owned, can not contain any motorcycles that I have owned. </p>
<p>Note: Type theory is a branch of mathematical logic that studies the concept of types, which are sets of values, and the relationships between them. It is used in programming languages to ensure that programs are well-formed and free of certain types of errors. In a type-theoretic system, each value is assigned a type, and the rules of the system ensure that operations are only applied to values of appropriate types. This can help prevent errors such as trying to add a number to a string, and can make it easier to reason about the behavior of a program. Type theories are used in the design and implementation of programming languages, and they form the basis of many programming language type systems.</p>
<p>Since a set can only contain objects or subsets of a given type, in order to define the set we must define it's type. In reality this can be very difficult to do. In order to define a "type" we must give explicit rules as to what properties that type might have as well as define which operations we can perform on that type. For example, a fairly easy to define type is the "whole number" (or integer) type. This type has the property of "state" which means that it can hold information of some kind. The state is stored a symbol between 0 and 9 (10 is actually 2 numbers which may or may not be obvious if you have never worked in other base system such as base 2). There is a bit of self-reference going on here but we will ignore that for now. </p>
<p>Note: In mathematics, a base system refers to the number of unique digits used to represent numbers in a particular numeral system. The most common base system is the decimal system, which uses 10 digits (0-9) to represent numbers. This system is used in everyday life, such as when counting money or measuring time. Another example is the binary system, which uses just 2 digits (0 and 1) to represent numbers. This system is used in computer science and digital electronics, as it is more convenient to represent numbers in electronic devices using a limited number of states, 0 and 1. Yet another example is the hexadecimal system, which uses 16 digits (0-9 and A-F) to represent numbers. This system is often used in computer programming to represent large binary numbers in a more compact form.</p>
<p>Number types also have the property of being mutable (their state can change) via the use of operators. Using the + operator we can increment the number to the next value in its series, and by using the - operator we can decrement the number. All other numerical operators you may be familiar with are derivate of the the + and - operators. Consider that multiplication is really just an abstraction built on the + operator and not a distinct operation. </p>
<p>Some other simple types that we might define would be "strings" which are a set of any numbers or letters. We can add two strings with a + operator in a somewhat similar way to how we use it on number types, but we instead of performing numerical addition, we do something call "concatenation" which means to combine two sets into one by appending set A to the beginning or end of set B, this creating a new longer set C (the size of C is equal to the size A + the size of B).</p>
<p>Since sets can only contain items of a given type or subsets (that also only contain that given type), we can not make any meaningful distinction between items in the set aside from the fact that they might be in different states. The are all essentially the same thing (the same type) and the same operators can apply to any of them equally. Because of this we know that any item in the set <em>could</em> equal any other item in the set assuming the same operations were performed to the items A and B and that items A and B were in the same state when the operations were performed. It is possible to cause irreversible states in which an item A can never obtain the same state as item B given any set of operations, but generally speaking, it is almost always possible to get item A into the same state as item B given the appropriate series of operations. It is also important to note that all items of a given type will have the same starting state by default (unless they are assigned an alternate state on creation). Because of this, it is possible for item A which is in its default state to achieve the state of <strong>any</strong> item B with the correct set of operations, any state that a type can exist in can be achieved from the starting state, otherwise that state would not be possible. To understand this, consider that assignment to a state is a type of operator (the assignment operator), if its possible to assign item B to a state that is not possible to obtain through other operators, we can still know that a default item A can achieve that state via the same assignment operator used on B. Remember that any item of a given type can be changed with the same set of operators that each other item of that type can. </p>
<p>Because all of the items in the set, are the same type, any meaningful distinction between them, or subset of item withing the superset is entirely superficial. The only true distinction between any item A and any item B or subset A and subset B is that of the state and the state alone. All of the items are in a very real sense, the "same thing". They just may or may not be in a different state. </p>
<p>If we consider the cells within the matrix of our simulation, we find that in order for them to exist within the matrix, which is by nature a set, they must also be of the same type. The type we have decided to call them is "cell". As I outlined several sections ago, there are 3 "actions" that can by taken on a cell. These actions can be thought of as operators on the "cell" type. To recap the three actions (or operators) are as follows:</p>
<ol>
<li>Survive: A living cell continues to live.</li>
<li>Thrive: A living cell continues to live. If the position is unoccupied (no living cell lives here) then a new cell is born at this position.</li>
<li>Die: A living cell will die.</li>
</ol>
<p>We also know that a cell can only have 2 possible states, alive and dead (on or off if you prefer). It should be fairly clear to see how any cell can reach either of these states regardless of it's current state via a simple application of 1 of our 3 operators. Really only 2 of these operators actually cause a state change, the first operator "Survive" can not affect change in the cell's state. Because of this, we can think of it is as not being a "real" operator. Right now its only purpose is to ensure that we have a action which corresponds to any of the 4 possible conditions that a cell can be in (as defined in a previous section). However if we consider the cells to instead of being on and off (1 or 0) to have an "age" as their state (which is a number type that can increment towards infinity) we could consider 0 to still be "dead" but any state over 0 to be alive. In this case, the "Survive" operator could be used to increment the "age" each time the cell survives a generation. If we do that we should also ensure that the "Thrive" operator has a side effect of incrementing age as well.</p>
<p>You may have noticed that we just used another type (number) to describe a property (the state) of a "cell" type. Types can be made up of other types. As a matter of fact this is often the case. Previously, I described a "string" type which can contain letters (characters). A string type is based on the "character" type. In systems where we can only really talk about whole numbers (like digital computing) we must construct ALL types from the base type which is in fact not a number in the sense we have been talking about (base 10) but instead of a binary number or (boolean) which can only be true or false (much like the cells in our original "cell" type). In order to construct the types we need to talk about base 10 numbers, we must first define abstraction on top of base 2. To get to character types, we must define a mapping system (or method of transposition) between a set of binary numbers and each character in our desired alphabet. The Boolean, (or binary number) is the base type in all of digital computing. As a matter of fact, it can be thought of as the base type for any kind of discrete reality since in discrete terms, any information can be described as a set of true of false statements about the information. </p>
<p>For example, consider the game 20 questions. This game implements a "binary decision tree" to come up with the name (description) of almost any object you want with only 20 binary digits (yes or no questions). If we knew which questions were asked at each "generation" of the game, we could know exactly what the final answer was (assuming it the answer was correct and unambiguous). Using a similar type of binary tree, we can describe any object that can exist within a discrete system given enough bits (binary digits) of information about that object. We can use this concept to construct any "type" of information that we want just be defining which binary questions must be asked about it in order to encode it's state.  </p>
<p>Let's take the letter "A" as an example of how letters are encoded into binary.</p>
<p>In the ASCII (American Standard Code for Information Interchange) system, each letter, number, and symbol is assigned a unique number between 0 and 127. The letter "A" is assigned the number 65.</p>
<p>To convert the number 65 to a set of booleans, we can use the process of repeatedly dividing by 2 and noting the remainder (the modulus).</p>
<p>65 divided by 2 is 32 with a remainder of 1.
32 divided by 2 is 16 with a remainder of 0.
16 divided by 2 is 8 with a remainder of 0.
8 divided by 2 is 4 with a remainder of 0.
4 divided by 2 is 2 with a remainder of 0.
2 divided by 2 is 1 with a remainder of 0.
1 divided by 2 is 0 with a remainder of 1.</p>
<p>So, the binary representation of the number 65 (which represents the letter "A" in ASCII) is the set of booleans (or bits) 01000001. Sets of exactly 8 bits come up in computing quite a bit (no pun intended), because of this we have given them the name "byte". In some systems a "byte" is not exactly 8 bits, but generally speaking when someone says a "byte" they are referring to 8 bits. A kilobyte is 1024 bytes which would be 1024*8 (or 8,192) bits. A megabyte is 1024 kilobytes and so on. Think about how complex of an object a modern computer with several terabytes of storage could contain. For some perspective, at the time of me writing this sentence, this document contains about 120k characters which is only about 1 million bits. That might seem like a lot, but a terabyte contains about 8e+12 (8,000,000,000,000 or 8 trillion) bits. My personal computer has over 12 terabytes of storage space (of which less than 20% is currently unoccupied). The entire Milky Way galaxy contains only about 300 billion stars. </p>
<p>We can see that any given set (or reality) has some sort of base type from which all other types are constructed. In the context of digital computing, this base type is the binary digit. The context of our physical reality this base type is the atom (or maybe the Planck length). In the context of our cellular automata simulation, the base type is the "cell". Nothing smaller than the cell can exist, thus we can not meaningfully talk about anything smaller than a cell within the context of our simulation. In turn, we know that any additional types we create within our simulation must be constructed from the base "cell" type.  </p>
<h2 id="abstractoperations">Abstract Operations</h2>
<p>Any new types that we construct with the base type can be thought of as an abstraction on top of the base type. It is really not a new type at all, it is just a set of rules (metadata) that can be applied to the base type to give the illusion of a new type actually existing. Just like we created an illusion of 2 dimensions by creating abstractions on top of our base one dimensional set before. Additionally, no new operators can actually be created. I mentioned before that on our "number" type, the only actual operators we had (or needed) were the + and - operators. Multiplication and division are just abstractions on top of those. </p>
<p>To illustrate this point, consider that multiplication can be thought of as a shorthand for repeated addition. For example, if we want to calculate the result of 3 x 4, we can think of it as adding 3 four times (3 + 3 + 3 + 3 = 12).</p>
<p>In mathematical notation, the multiplication operator (x) is used to represent this repeated addition. So, 3 x 4 can be written as 3 + 3 + 3 + 3, or more succinctly as 3 * 4. However the multiplication operator is not distinct from the addition operator. It is just a way of expressing that we want multiple iterations of the addition operator. 2 x 4 is just a quick way of saying we want to add 2 to itself 4 times (after all we would say "2 <em>times</em> 4").</p>
<p>This abstraction of multiplication over addition can be extended to any number, for example:</p>
<p>5 x 3 = 5 + 5 + 5</p>
<p>8 x 4 = 8 + 8 + 8 + 8</p>
<p>And so on.</p>
<p>One way to think of it is that multiplication gives a way to represent "scaling" of numbers. For example, if you want to represent two times of a number, you can write 2*x instead of writing x+x, this is not just a shorthand but also a more efficient way of writing.</p>
<p>This abstraction of multiplication over addition can be extended to more complex mathematical operations, such as matrix multiplication and other operations that involve the use of numbers. It also leads to more advanced mathematical concepts such as commutativity, distributivity and associativity of multiplication over addition.</p>
<p>We could do a similar exercise to explain how division is really just subtraction until we reach zero. It is really true that any operation we can do to a number under the umbrella of formal mathematics is really just some abstraction on addition or subtraction. As a matter of fact, we can admit that negative numbers exist, we don't even need the subtraction operator any more since adding a negative number yields the exact same result (in the same way that division is an inversion of multiplication). We could also use this idea to consider that negative numbers and subfraction existing in the same rule set is a redundancy at best an a paradox at the worst. </p>
<h1 id="contradictionsandabstractions">Contradictions and Abstractions</h1>
<p>Can we really subtract by a negative amount? Is that not a "double negative" which should be considered a logical error? If zero is "nothing" or "empty" how can a number possibly be less than nothing or less than empty? We can move (take that Zeno) only in a positive manner; It is not possible to move a negative distance. If we move to point B from point A, a distance of N units, and then we move back from point B to point A (a distance of N units) did we ever move a negative amount of distance? From the perspective of point A we did. We could even argue that from the perspective of point B we did as well. However from our perspective we have only moved in an absolute fashion. We were "here" and then we moved some positive amount of distance to "there". In this way, we can see that the concept subtraction (or negativity) itself may not be valid. We can either have subtract by an absolute value or we can add by a negative value. It should not be possible to do both in the same system. In fact, it's really not possible even in the context of pure math. To do so would cause a contradiction. To avoid this contradiction, we created a rule (or abstraction), on the concept of linearity that allowed us to simultaneously consider the concepts of subtraction and negativity in the same rule set.  </p>
<p>The rule for subtracting negative numbers is to change the subtraction sign to addition, and then change the sign of the number being subtracted. For example:</p>
<p>5 - (-2) = 5 + 2 = 7</p>
<p>This rule can be derived from the fact that subtraction is the inverse operation of addition. So, to subtract a negative number, we change the subtraction sign to addition, and then negate the number being subtracted.</p>
<p>The contradiction in this rule arises because when we subtract a negative number, we are actually adding a positive number. However, the result is the same as if we had subtracted a positive number. This can be confusing because the operation and the sign of the number being subtracted do not match.</p>
<p>To deal with this contradiction, we use abstractions, such as the rule for subtracting negative numbers, to make the process of subtracting negative numbers more manageable and consistent. It allows us to operate with negative numbers without getting confused. This abstraction also makes it possible to use negative numbers in more complex mathematical operations, such as algebra and calculus, where it is important to have a consistent and well-defined set of rules for dealing with negative numbers.</p>
<p>It's also worth noting that the ability to subtract negative numbers and the use of negative numbers in general is a relatively recent development in mathematics, and it's a concept that is not always intuitive. It's an abstraction that we use to represent certain situations in the physical world, such as debt, temperature, and more.</p>
<p>What we have done here is effectively "abstracted away" the contradictions inherent in "negative subtraction". However as a possibly unintended side effect of this abstraction we have created new problems. For example, we do not have solution to the square root of negative 1 which seems by all means like it should not be as hard to solve for as it is. To deal with this new problem, we created yet another abstraction called "i" which we can use to represent the hypothetical solution to this problem. This allows engineers to move on with their lives but causes mathematicians to stop in their tracks (this is a joke). Another example of an abstraction similar to "i" (though it was not caused by gaining the ability to subtract negative numbers) is the symbol Ï (pi) which is the ratio of a perfect circles circumference to it's diameter. </p>
<h1 id="definingcelltypes">Defining Cell Types</h1>
<p>We should now have a fairly solid understanding of types and sets as well as how types can be constructed from several base types that are in turn all constructed from some base type inherent to that system. Using this understanding we can start to discuss theoretical distinctions between our population of cells, the cells themselves and the "organisms" that arrive from certain configurations of these cells. </p>
<h2 id="whatshapescantexist">What shapes cant exist?</h2>
<p>Perfect circles</p>
<h1 id="lifedeathcellularautomataakawtfisgoingon">LIFE, DEATH &amp; CELLULAR AUTOMATA: AKA, WTF IS GOING ON?</h1>
<p>///</p>
<p>we can exist in other dimensions but at the same time we do not truly exist there. We are anchored to base reality. </p></div><br><br><br>
<hr>
<div class="footer">
  <div>
    &copy; Mathieu Dombrock 2023 | <a href="mailto:dombrock.mathieu@gmail.com">dombrock.mathieu@gmail.com</a> | 
    <a href="https://github.com/matdombrock" target="_blank">Github</a> | 
    <a href="https://github.com/matdombrock/SteelSky" target="_blank">SteelSky</a> |
    <small id="visits"></small>
  </div>
  <div>
    <small style="text-align:right;">
    </small>
  </div>

  <script>
    let visits = localStorage.getItem('visits');
    if(visits === undefined){
      visits = 0;
    }
    visits++;
    localStorage.setItem('visits', visits);
    document.getElementById('visits').innerHTML = "This browser has been here " + visits + " times";
  </script>
</div>